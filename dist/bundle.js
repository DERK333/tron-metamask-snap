(()=>{"use strict";var e={64:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.translations=void 0,t.translations={en:{"common.yes":"Yes","common.no":"No","common.confirm":"Confirm","common.cancel":"Cancel","common.continue":"Continue","common.close":"Close","common.error":"Error","common.success":"Success","common.warning":"Warning","common.trx":"TRX","common.energy":"Energy","common.bandwidth":"Bandwidth","connection.title":"Connect to TRON Network","connection.description":"This will create a TRON account derived from your MetaMask seed phrase.","connection.accountAddress":"Account Address:","connection.network":"Network:","connection.success":"Successfully connected to TRON network!","connection.rejected":"User rejected connection","connection.failed":"Failed to connect to TRON","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"Send TRON Transaction","transaction.to":"To:","transaction.from":"From:","transaction.amount":"Amount:","transaction.memo":"Memo:","transaction.estimatedFee":"Estimated Fee:","transaction.total":"Total:","transaction.success":"Transaction sent successfully!","transaction.failed":"Transaction failed","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"Low","risk.medium":"Medium","risk.high":"High","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"Unknown error","error.invalidParams":"Invalid parameters","error.userRejected":"User rejected the request","error.notConnected":"Not connected to TRON network","error.methodNotFound":"Method not found"},zh:{"common.yes":"æ˜¯","common.no":"å¦","common.confirm":"ç¡®è®¤","common.cancel":"å–æ¶ˆ","common.continue":"ç»§ç»­","common.close":"å…³é—­","common.error":"é”™è¯¯","common.success":"æˆåŠŸ","common.warning":"è­¦å‘Š","common.trx":"TRX","common.energy":"èƒ½é‡","common.bandwidth":"å¸¦å®½","connection.title":"è¿žæŽ¥åˆ° TRON ç½‘ç»œ","connection.description":"è¿™å°†æ ¹æ®æ‚¨çš„ MetaMask ç§å­çŸ­è¯­åˆ›å»ºä¸€ä¸ª TRON è´¦æˆ·ã€‚","connection.accountAddress":"è´¦æˆ·åœ°å€ï¼š","connection.network":"ç½‘ç»œï¼š","connection.success":"æˆåŠŸè¿žæŽ¥åˆ° TRON ç½‘ç»œï¼","connection.rejected":"ç”¨æˆ·æ‹’ç»è¿žæŽ¥","connection.failed":"è¿žæŽ¥åˆ° TRON å¤±è´¥","account.title":"TRON è´¦æˆ·","account.address":"åœ°å€ï¼š","account.balance":"ä½™é¢ï¼š","account.network":"ç½‘ç»œï¼š","account.failed":"èŽ·å–è´¦æˆ·å¤±è´¥","transaction.send":"å‘é€ TRON äº¤æ˜“","transaction.to":"æŽ¥æ”¶æ–¹ï¼š","transaction.from":"å‘é€æ–¹ï¼š","transaction.amount":"é‡‘é¢ï¼š","transaction.memo":"å¤‡æ³¨ï¼š","transaction.estimatedFee":"é¢„ä¼°è´¹ç”¨ï¼š","transaction.total":"æ€»è®¡ï¼š","transaction.success":"äº¤æ˜“å‘é€æˆåŠŸï¼","transaction.failed":"äº¤æ˜“å¤±è´¥","transaction.cancelled":"ç”¨æˆ·å–æ¶ˆäº¤æ˜“","transaction.invalidAddress":"æ— æ•ˆçš„ TRON åœ°å€","transaction.invalidAmount":"æ— æ•ˆé‡‘é¢","transaction.insufficientBalance":"ä½™é¢ä¸è¶³","sign.title":"ç­¾åæ¶ˆæ¯","sign.message":"è¦ç­¾åçš„æ¶ˆæ¯ï¼š","sign.warning":"åªç­¾åæ¥è‡ªå¯ä¿¡æ¥æºçš„æ¶ˆæ¯ï¼","sign.success":"æ¶ˆæ¯ç­¾åæˆåŠŸï¼","sign.failed":"ç­¾åå¤±è´¥","sign.cancelled":"ç”¨æˆ·å–æ¶ˆç­¾å","network.switchTitle":"åˆ‡æ¢ TRON ç½‘ç»œ","network.switchTo":"åˆ‡æ¢åˆ° TRON {{network}}ï¼Ÿ","network.switchDescription":"è¿™å°†æ›´æ”¹æ‚¨å½“å‰çš„ç½‘ç»œè¿žæŽ¥ã€‚","network.switched":"å·²åˆ‡æ¢åˆ° TRON {{network}}","network.invalidNetwork":'æ— æ•ˆç½‘ç»œã€‚è¯·ä½¿ç”¨ "mainnet" æˆ– "testnet"',"network.switchCancelled":"ç”¨æˆ·å–æ¶ˆç½‘ç»œåˆ‡æ¢","network.switchFailed":"åˆ‡æ¢ç½‘ç»œå¤±è´¥","dapp.connectTitle":"è¿žæŽ¥åˆ° {{name}}","dapp.connectDescription":"æ­¤ç½‘ç«™æƒ³è¦ï¼š","dapp.viewAddress":"æŸ¥çœ‹æ‚¨çš„ TRON åœ°å€","dapp.requestTransactions":"è¯·æ±‚äº¤æ˜“æ‰¹å‡†","dapp.connected":"å·²è¿žæŽ¥åˆ° {{name}}","dapp.disconnected":"å·²æ–­å¼€ä¸Ž {{name}} çš„è¿žæŽ¥","dapp.rejected":"è¿žæŽ¥è¯·æ±‚è¢«æ‹’ç»","dapp.activeSessions":"æ´»è·ƒçš„ dApp è¿žæŽ¥","dapp.noSessions":"æ²¡æœ‰æ´»è·ƒè¿žæŽ¥","dapp.connectedAt":"è¿žæŽ¥æ—¶é—´ï¼š","staking.title":"è´¨æŠ¼ TRX","staking.unstakeTitle":"è§£é™¤è´¨æŠ¼ TRX","staking.amount":"æ‚¨å³å°†ä¸º **{{resource}}** è´¨æŠ¼ **{{amount}} TRX**ã€‚","staking.unstakeAmount":"æ‚¨å³å°†ä»Ž **{{resource}}** è§£é™¤è´¨æŠ¼ **{{amount}} TRX**ã€‚","staking.details":"è´¨æŠ¼è¯¦æƒ…ï¼š","staking.resource":"èµ„æºï¼š","staking.lockPeriod":"é”å®šæœŸï¼š3å¤©","staking.unstakeLockPeriod":"è§£é™¤è´¨æŠ¼çš„ TRX å°†é”å®š14å¤©","staking.benefits":"å¥½å¤„ï¼š","staking.earnVoting":"èŽ·å¾—æŠ•ç¥¨æƒï¼ˆ1 TRX = 1 ç¥¨ï¼‰","staking.getFree":"èŽ·å¾—å…è´¹çš„{{resource}}ç”¨äºŽäº¤æ˜“","staking.supportNetwork":"æ”¯æŒ TRON ç½‘ç»œ","staking.loseVoting":"æ‚¨å°†å¤±åŽ»æ­¤é‡‘é¢çš„æŠ•ç¥¨æƒ","staking.reducedResource":"å…è´¹{{resource}}å°†å‡å°‘","staking.success":"æˆåŠŸä¸º{{resource}}è´¨æŠ¼{{amount}} TRX","staking.unstakeSuccess":"æˆåŠŸä»Ž{{resource}}è§£é™¤è´¨æŠ¼{{amount}} TRX","staking.cancelled":"ç”¨æˆ·å–æ¶ˆè´¨æŠ¼","staking.unstakeCancelled":"ç”¨æˆ·å–æ¶ˆè§£é™¤è´¨æŠ¼","staking.failed":"è´¨æŠ¼å¤±è´¥","staking.unstakeFailed":"è§£é™¤è´¨æŠ¼å¤±è´¥","staking.invalidAmount":"æ— æ•ˆçš„è´¨æŠ¼é‡‘é¢","staking.invalidResource":"æ— æ•ˆçš„èµ„æºç±»åž‹","stakingInfo.title":"è´¨æŠ¼ä¿¡æ¯","stakingInfo.stakedBalance":"è´¨æŠ¼ä½™é¢ï¼š","stakingInfo.total":"æ€»è®¡ï¼š","stakingInfo.forEnergy":"èƒ½é‡è´¨æŠ¼ï¼š","stakingInfo.forBandwidth":"å¸¦å®½è´¨æŠ¼ï¼š","stakingInfo.votingPower":"æŠ•ç¥¨æƒï¼š","stakingInfo.available":"å¯ç”¨ï¼š","stakingInfo.activeVotes":"æ´»è·ƒæŠ•ç¥¨ï¼š","stakingInfo.noVotes":"æ²¡æœ‰æ´»è·ƒæŠ•ç¥¨","stakingInfo.rewards":"å¥–åŠ±ï¼š","stakingInfo.votes":"ç¥¨","voting.title":"ä¸ºè¶…çº§ä»£è¡¨æŠ•ç¥¨","voting.description":"ä½¿ç”¨æ‚¨çš„æŠ•ç¥¨æƒæ”¯æŒè¶…çº§ä»£è¡¨","voting.selectedSR":"é€‰å®šçš„ SRï¼š","voting.currentVotes":"å½“å‰ç¥¨æ•°ï¼š","voting.votesToCast":"æŠ•ç¥¨æ•°ï¼š","voting.availableVotes":"å¯ç”¨ç¥¨æ•°ï¼š","voting.success":"æˆåŠŸä¸º{{name}}æŠ•{{votes}}ç¥¨","voting.cancelled":"ç”¨æˆ·å–æ¶ˆæŠ•ç¥¨","voting.failed":"æŠ•ç¥¨å¤±è´¥","voting.insufficientVotes":"æŠ•ç¥¨æƒä¸è¶³","voting.invalidVotes":"æ— æ•ˆçš„æŠ•ç¥¨æ•°","sr.title":"é¡¶çº§è¶…çº§ä»£è¡¨","sr.description":"ä¸º SR æŠ•ç¥¨ä»¥èŽ·å¾—å¥–åŠ±å¹¶æ”¯æŒç½‘ç»œ","sr.votes":"ç¥¨æ•°ï¼š","sr.productivity":"ç”Ÿäº§çŽ‡ï¼š","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... ä»¥åŠæ›´å¤š","withdrawal.title":"æå–è¿‡æœŸä½™é¢","withdrawal.available":"å¯æå–ï¼š","withdrawal.description":"è¿™å°†æå–æ‰€æœ‰è¿‡æœŸçš„è§£å†»ä½™é¢åˆ°æ‚¨çš„è´¦æˆ·ã€‚","withdrawal.success":"æˆåŠŸæå–{{amount}} TRX","withdrawal.nothingToWithdraw":"æ²¡æœ‰è¿‡æœŸä½™é¢å¯æå–","withdrawal.cancelled":"ç”¨æˆ·å–æ¶ˆæå–","withdrawal.failed":"æå–å¤±è´¥","preview.networkStatus":"ç½‘ç»œçŠ¶æ€","preview.congestion":"æ‹¥å µåº¦ï¼š","preview.blockTime":"å‡ºå—æ—¶é—´ï¼š","preview.currentBlock":"å½“å‰åŒºå—ï¼š","preview.riskAssessment":"é£Žé™©è¯„ä¼°","preview.level":"é£Žé™©ç­‰çº§ï¼š","preview.warnings":"è­¦å‘Šï¼š","preview.feeEstimation":"è´¹ç”¨ä¼°ç®—","preview.estimatedCost":"é¢„ä¼°æˆæœ¬ï¼š","preview.energyRequired":"æ‰€éœ€èƒ½é‡ï¼š","preview.bandwidthRequired":"æ‰€éœ€å¸¦å®½ï¼š","preview.contractInteraction":"åˆçº¦äº¤äº’","preview.contractType":"åˆçº¦ç±»åž‹ï¼š","preview.method":"æ–¹æ³•ï¼š","preview.simulation":"äº¤æ˜“æ¨¡æ‹Ÿ","preview.simulationSuccess":"æ¨¡æ‹ŸæˆåŠŸ","preview.simulationFailed":"æ¨¡æ‹Ÿå¤±è´¥","preview.energyUsed":"ä½¿ç”¨çš„èƒ½é‡ï¼š","preview.bandwidthUsed":"ä½¿ç”¨çš„å¸¦å®½ï¼š","risk.low":"ä½Ž","risk.medium":"ä¸­","risk.high":"é«˜","risk.veryHighAmount":"äº¤æ˜“é‡‘é¢éžå¸¸é«˜","risk.newAddress":"æŽ¥æ”¶æ–¹æ˜¯æ²¡æœ‰åŽ†å²è®°å½•çš„æ–°åœ°å€","risk.contractUnverified":"ä¸ŽæœªéªŒè¯çš„åˆçº¦äº¤äº’","risk.insufficientBalance":"ä½™é¢ä¸è¶³ä»¥æ”¯ä»˜äº¤æ˜“å’Œè´¹ç”¨","error.unknown":"æœªçŸ¥é”™è¯¯","error.invalidParams":"æ— æ•ˆå‚æ•°","error.userRejected":"ç”¨æˆ·æ‹’ç»è¯·æ±‚","error.notConnected":"æœªè¿žæŽ¥åˆ° TRON ç½‘ç»œ","error.methodNotFound":"æ‰¾ä¸åˆ°æ–¹æ³•"},es:{"common.yes":"SÃ­","common.no":"No","common.confirm":"Confirmar","common.cancel":"Cancelar","common.continue":"Continuar","common.close":"Cerrar","common.error":"Error","common.success":"Ã‰xito","common.warning":"Advertencia","common.trx":"TRX","common.energy":"EnergÃ­a","common.bandwidth":"Ancho de banda","connection.title":"Conectar a la Red TRON","connection.description":"Esto crearÃ¡ una cuenta TRON derivada de su frase semilla de MetaMask.","connection.accountAddress":"DirecciÃ³n de cuenta:","connection.network":"Red:","connection.success":"Â¡Conectado exitosamente a la red TRON!","connection.rejected":"Usuario rechazÃ³ la conexiÃ³n","connection.failed":"Error al conectar a TRON","account.title":"Cuenta TRON","account.address":"DirecciÃ³n:","account.balance":"Saldo:","account.network":"Red:","account.failed":"Error al obtener cuenta","transaction.send":"Enviar TransacciÃ³n TRON","transaction.to":"Para:","transaction.from":"De:","transaction.amount":"Cantidad:","transaction.memo":"Memo:","transaction.estimatedFee":"Tarifa estimada:","transaction.total":"Total:","transaction.success":"Â¡TransacciÃ³n enviada con Ã©xito!","transaction.failed":"TransacciÃ³n fallida","transaction.cancelled":"TransacciÃ³n cancelada por usuario","transaction.invalidAddress":"DirecciÃ³n TRON invÃ¡lida","transaction.invalidAmount":"Cantidad invÃ¡lida","transaction.insufficientBalance":"Saldo insuficiente","sign.title":"Firmar Mensaje","sign.message":"Mensaje a firmar:","sign.warning":"Â¡Solo firme mensajes de fuentes confiables!","sign.success":"Â¡Mensaje firmado exitosamente!","sign.failed":"Error al firmar mensaje","sign.cancelled":"Firma cancelada por usuario","network.switchTitle":"Cambiar Red TRON","network.switchTo":"Â¿Cambiar a TRON {{network}}?","network.switchDescription":"Esto cambiarÃ¡ su conexiÃ³n de red actual.","network.switched":"Cambiado a TRON {{network}}","network.invalidNetwork":'Red invÃ¡lida. Use "mainnet" o "testnet"',"network.switchCancelled":"Cambio de red cancelado por usuario","network.switchFailed":"Error al cambiar red","dapp.connectTitle":"Conectar a {{name}}","dapp.connectDescription":"Este sitio desea:","dapp.viewAddress":"Ver su direcciÃ³n TRON","dapp.requestTransactions":"Solicitar aprobaciones de transacciones","dapp.connected":"Conectado a {{name}}","dapp.disconnected":"Desconectado de {{name}}","dapp.rejected":"Solicitud de conexiÃ³n rechazada","dapp.activeSessions":"Conexiones dApp Activas","dapp.noSessions":"Sin conexiones activas","dapp.connectedAt":"Conectado:","staking.title":"Apostar TRX","staking.unstakeTitle":"Desapostar TRX","staking.amount":"EstÃ¡ a punto de apostar **{{amount}} TRX** para **{{resource}}**.","staking.unstakeAmount":"EstÃ¡ a punto de desapostar **{{amount}} TRX** de **{{resource}}**.","staking.details":"Detalles de Apuesta:","staking.resource":"Recurso:","staking.lockPeriod":"PerÃ­odo de bloqueo: 3 dÃ­as","staking.unstakeLockPeriod":"TRX desapostado estarÃ¡ bloqueado por 14 dÃ­as","staking.benefits":"Beneficios:","staking.earnVoting":"Ganar derechos de voto (1 TRX = 1 voto)","staking.getFree":"Obtener {{resource}} gratis para transacciones","staking.supportNetwork":"Apoyar la red TRON","staking.loseVoting":"PerderÃ¡ derechos de voto por esta cantidad","staking.reducedResource":"{{resource}} gratis se reducirÃ¡","staking.success":"Apostado exitosamente {{amount}} TRX para {{resource}}","staking.unstakeSuccess":"Desapostado exitosamente {{amount}} TRX de {{resource}}","staking.cancelled":"Apuesta cancelada por usuario","staking.unstakeCancelled":"Desapuesta cancelada por usuario","staking.failed":"Apuesta fallida","staking.unstakeFailed":"Desapuesta fallida","staking.invalidAmount":"Cantidad de apuesta invÃ¡lida","staking.invalidResource":"Tipo de recurso invÃ¡lido","stakingInfo.title":"InformaciÃ³n de Apuesta","stakingInfo.stakedBalance":"Saldo Apostado:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"Para EnergÃ­a:","stakingInfo.forBandwidth":"Para Ancho de Banda:","stakingInfo.votingPower":"Poder de Voto:","stakingInfo.available":"Disponible:","stakingInfo.activeVotes":"Votos Activos:","stakingInfo.noVotes":"Sin votos activos","stakingInfo.rewards":"Recompensas:","stakingInfo.votes":"votos","voting.title":"Votar por Super Representantes","voting.description":"Use su poder de voto para apoyar Super Representantes","voting.selectedSR":"SR seleccionado:","voting.currentVotes":"Votos actuales:","voting.votesToCast":"Votos a emitir:","voting.availableVotes":"Votos disponibles:","voting.success":"Votado exitosamente {{votes}} para {{name}}","voting.cancelled":"VotaciÃ³n cancelada por usuario","voting.failed":"VotaciÃ³n fallida","voting.insufficientVotes":"Poder de voto insuficiente","voting.invalidVotes":"Recuento de votos invÃ¡lido","sr.title":"Top Super Representantes","sr.description":"Vote por SRs para ganar recompensas y apoyar la red","sr.votes":"Votos:","sr.productivity":"Productividad:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... y mÃ¡s","withdrawal.title":"Retirar Saldo Expirado","withdrawal.available":"Disponible para retirar:","withdrawal.description":"Esto retirarÃ¡ todo el saldo descongelado expirado a su cuenta.","withdrawal.success":"Retirado exitosamente {{amount}} TRX","withdrawal.nothingToWithdraw":"Sin saldo expirado para retirar","withdrawal.cancelled":"Retiro cancelado por usuario","withdrawal.failed":"Retiro fallido","preview.networkStatus":"Estado de Red","preview.congestion":"CongestiÃ³n:","preview.blockTime":"Tiempo de Bloque:","preview.currentBlock":"Bloque Actual:","preview.riskAssessment":"EvaluaciÃ³n de Riesgo","preview.level":"Nivel de Riesgo:","preview.warnings":"Advertencias:","preview.feeEstimation":"EstimaciÃ³n de Tarifa","preview.estimatedCost":"Costo Estimado:","preview.energyRequired":"EnergÃ­a Requerida:","preview.bandwidthRequired":"Ancho de Banda Requerido:","preview.contractInteraction":"InteracciÃ³n de Contrato","preview.contractType":"Tipo de Contrato:","preview.method":"MÃ©todo:","preview.simulation":"SimulaciÃ³n de TransacciÃ³n","preview.simulationSuccess":"SimulaciÃ³n exitosa","preview.simulationFailed":"SimulaciÃ³n fallida","preview.energyUsed":"EnergÃ­a usada:","preview.bandwidthUsed":"Ancho de banda usado:","risk.low":"Bajo","risk.medium":"Medio","risk.high":"Alto","risk.veryHighAmount":"Cantidad de transacciÃ³n muy alta","risk.newAddress":"Destinatario es una direcciÃ³n nueva sin historial","risk.contractUnverified":"Interactuando con contrato no verificado","risk.insufficientBalance":"Saldo insuficiente para transacciÃ³n + tarifas","error.unknown":"Error desconocido","error.invalidParams":"ParÃ¡metros invÃ¡lidos","error.userRejected":"Usuario rechazÃ³ la solicitud","error.notConnected":"No conectado a red TRON","error.methodNotFound":"MÃ©todo no encontrado"},fr:{"common.yes":"Oui","common.no":"Non","common.confirm":"Confirmer","common.cancel":"Annuler","common.continue":"Continuer","common.close":"Fermer","common.error":"Erreur","common.success":"SuccÃ¨s","common.warning":"Avertissement","common.trx":"TRX","common.energy":"Ã‰nergie","common.bandwidth":"Bande passante","connection.title":"Connexion au RÃ©seau TRON","connection.description":"Cela crÃ©era un compte TRON dÃ©rivÃ© de votre phrase de rÃ©cupÃ©ration MetaMask.","connection.accountAddress":"Adresse du compte:","connection.network":"RÃ©seau:","connection.success":"ConnectÃ© avec succÃ¨s au rÃ©seau TRON!","connection.rejected":"Connexion refusÃ©e par l'utilisateur","connection.failed":"Ã‰chec de la connexion Ã  TRON","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"Envoyer une Transaction TRON","transaction.to":"Ã€:","transaction.from":"De:","transaction.amount":"Montant:","transaction.memo":"Memo:","transaction.estimatedFee":"Frais estimÃ©s:","transaction.total":"Total:","transaction.success":"Transaction envoyÃ©e avec succÃ¨s!","transaction.failed":"Transaction Ã©chouÃ©e","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"Low","risk.medium":"Medium","risk.high":"High","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"Erreur inconnue","error.invalidParams":"ParamÃ¨tres invalides","error.userRejected":"Demande rejetÃ©e par l'utilisateur","error.notConnected":"Non connectÃ© au rÃ©seau TRON","error.methodNotFound":"MÃ©thode non trouvÃ©e"},ja:{"common.yes":"ã¯ã„","common.no":"ã„ã„ãˆ","common.confirm":"ç¢ºèª","common.cancel":"ã‚­ãƒ£ãƒ³ã‚»ãƒ«","common.continue":"ç¶šè¡Œ","common.close":"é–‰ã˜ã‚‹","common.error":"ã‚¨ãƒ©ãƒ¼","common.success":"æˆåŠŸ","common.warning":"è­¦å‘Š","common.trx":"TRX","common.energy":"ã‚¨ãƒãƒ«ã‚®ãƒ¼","common.bandwidth":"å¸¯åŸŸå¹…","connection.title":"TRONãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æŽ¥ç¶š","connection.description":"MetaMaskã®ã‚·ãƒ¼ãƒ‰ãƒ•ãƒ¬ãƒ¼ã‚ºã‹ã‚‰æ´¾ç”Ÿã—ãŸTRONã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚","connection.accountAddress":"ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ï¼š","connection.network":"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼š","connection.success":"TRONãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æ­£å¸¸ã«æŽ¥ç¶šã—ã¾ã—ãŸï¼","connection.rejected":"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŽ¥ç¶šã‚’æ‹’å¦ã—ã¾ã—ãŸ","connection.failed":"TRONã¸ã®æŽ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"TRONãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡","transaction.to":"å®›å…ˆï¼š","transaction.from":"é€ä¿¡å…ƒï¼š","transaction.amount":"é‡‘é¡ï¼š","transaction.memo":"Memo:","transaction.estimatedFee":"Estimated Fee:","transaction.total":"Total:","transaction.success":"ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒæ­£å¸¸ã«é€ä¿¡ã•ã‚Œã¾ã—ãŸï¼","transaction.failed":"ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå¤±æ•—ã—ã¾ã—ãŸ","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"ä½Ž","risk.medium":"ä¸­","risk.high":"é«˜","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"ä¸æ˜Žãªã‚¨ãƒ©ãƒ¼","error.invalidParams":"ç„¡åŠ¹ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿","error.userRejected":"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ‹’å¦ã—ã¾ã—ãŸ","error.notConnected":"TRONãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æŽ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“","error.methodNotFound":"ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"}}},116:(e,t)=>{function n(e){return!(!e||"string"!=typeof e)&&/^T[A-Za-z0-9]{33}$/.test(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.validateTronAddress=n,t.formatTrx=function(e){return(("string"==typeof e?parseFloat(e):e)/1e6).toFixed(6)},t.trxToSun=function(e){const t="string"==typeof e?parseFloat(e):e;return Math.floor(1e6*t)},t.truncateAddress=function(e,t=6,n=4){return!e||e.length<=t+n?e:`${e.slice(0,t)}...${e.slice(-n)}`},t.formatTimestamp=function(e){return new Date(e).toLocaleString()},t.validateAmount=function(e){if(!e||"string"!=typeof e)return!1;const t=parseFloat(e);return!isNaN(t)&&t>0&&t<=1e6},t.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},t.parseErrorMessage=function(e){return"string"==typeof e?e:e?.message?e.message:e?.error?e.error:"An unknown error occurred"},t.validateNetwork=function(e){return"mainnet"===e||"testnet"===e},t.formatBalance=function(e,t=6){return e.toFixed(t).replace(/\.?0+$/,"")},t.isValidTronAddress=function(e){return n(e)&&34===e.length},t.sanitizeInput=function(e){return"string"!=typeof e?"":e.trim().replace(/[<>]/g,"")},t.calculateTxFee=function(){return 1},t.checkSufficientBalance=function(e,t){return t>=parseFloat(e)+1}},218:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TronService=void 0;const a=n(576);t.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const e=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),t=await(0,a.getBIP44AddressKeyDeriver)(e),n=await t(195),s=this.privateKeyToAddress(n.privateKey||"");return this.account={address:s,privateKey:n.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(e){throw new Error(`Failed to connect: ${e?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const e=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!e?.tronAccount)throw new Error("No account found. Please connect first.");this.account=e.tronAccount}return this.account}async getBalance(){const e=await this.getAccount();try{const t=await this.makeRpcCall("wallet/getaccount",{address:e.address,visible:!0});return t?.balance?t.balance/1e6:0}catch(e){throw new Error(`Failed to get balance: ${e?.message||"Unknown error"}`)}}async sendTransaction(e,t,n){const a=await this.getAccount();try{const n={to_address:e,owner_address:a.address,amount:Math.floor(1e6*parseFloat(t)),visible:!0},s=await this.makeRpcCall("wallet/createtransaction",n);if(!s?.txID)throw new Error("Failed to create transaction");const r=await this.signTransaction(s,a.privateKey),o=await this.makeRpcCall("wallet/broadcasttransaction",r);if(!o?.result)throw new Error(o?.message||"Transaction broadcast failed");return s.txID}catch(e){throw new Error(`Transaction failed: ${e?.message||"Unknown error"}`)}}async signMessage(e){const t=await this.getAccount();try{const n=Buffer.from(e,"utf8").toString("hex");return await this.signHex(n,t.privateKey)}catch(e){throw new Error(`Message signing failed: ${e?.message||"Unknown error"}`)}}async getTransactionHistory(){const e=await this.getAccount();try{const t=await this.makeRpcCall("v1/accounts/"+e.address+"/transactions",null,"GET");return t?.data?t.data.map(e=>({txId:e.txID||"",type:this.getTransactionType(e.raw_data?.contract?.[0]?.type||""),amount:(e.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:e.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:e.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:e.block_timestamp||0,status:e.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(e){return[]}}async switchNetwork(e){this.network=e,this.account&&(this.account.network=e,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(e,t,n="POST"){const a="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",s={method:n,headers:{"Content-Type":"application/json"}};t&&"POST"===n&&(s.body=JSON.stringify(t));const r=await fetch(`${a}/${e}`,s);if(!r.ok)throw new Error(`RPC call failed: ${r.statusText}`);return await r.json()}privateKeyToAddress(e){return"T"+this.simpleHash(e).slice(0,33)}simpleHash(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t&=t;return Math.abs(t).toString(16).padStart(33,"0")}async signTransaction(e,t){const n=await this.signHex(e.txID,t);return{...e,signature:[n]}}async signHex(e,t){return this.simpleHash(e+t)}getTransactionType(e){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract",FreezeBalanceV2Contract:"Stake TRX",UnfreezeBalanceV2Contract:"Unstake TRX",VoteWitnessContract:"Vote for SR",WithdrawExpireUnfreezeContract:"Withdraw Unstaked"}[e]||"Unknown"}async stakeTRX(e,t,n=3){if(!this.account)throw new Error("Not connected");const a=Math.round(1e6*parseFloat(e)),s={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,frozen_balance:a,resource:t,frozen_duration:n},type_url:"type.googleapis.com/protocol.FreezeBalanceV2Contract"},type:"FreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`stake-${this.account.address}-${e}-${Date.now()}`)},r=await this.signTransaction(s,this.account.privateKey),o=await this.makeRpcCall("/wallet/broadcasttransaction",r);return o?.txid||s.txID}async unstakeTRX(e,t){if(!this.account)throw new Error("Not connected");const n=Math.round(1e6*parseFloat(e)),a={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,unfreeze_balance:n,resource:t},type_url:"type.googleapis.com/protocol.UnfreezeBalanceV2Contract"},type:"UnfreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`unstake-${this.account.address}-${e}-${Date.now()}`)},s=await this.signTransaction(a,this.account.privateKey),r=await this.makeRpcCall("/wallet/broadcasttransaction",s);return r?.txid||a.txID}async voteForSR(e){if(!this.account)throw new Error("Not connected");const t={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,votes:e.map(e=>({vote_address:e.address,vote_count:e.count}))},type_url:"type.googleapis.com/protocol.VoteWitnessContract"},type:"VoteWitnessContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`vote-${this.account.address}-${JSON.stringify(e)}-${Date.now()}`)},n=await this.signTransaction(t,this.account.privateKey),a=await this.makeRpcCall("/wallet/broadcasttransaction",n);return a?.txid||t.txID}async getStakingInfo(){if(!this.account)throw new Error("Not connected");try{const e=await this.makeRpcCall("/wallet/getaccountresource",{address:this.account.address},"POST"),t=(await this.makeRpcCall("/wallet/getdelegatedresourceaccountindexv2",{value:this.account.address},"POST"),await this.makeRpcCall("/wallet/getaccount",{address:this.account.address},"POST")),n=e?.frozen_balance_for_energy||0,a=e?.frozen_balance_for_bandwidth||0;return{frozen:(n+a)/1e6,frozenEnergy:n/1e6,frozenBandwidth:a/1e6,votes:t?.votes?.map(e=>({address:e.vote_address,name:`SR ${e.vote_address.substring(0,10)}...`,votes:e.vote_count}))||[],rewards:0,canUnfreezeIn:0}}catch(e){return{frozen:0,frozenEnergy:0,frozenBandwidth:0,votes:[],rewards:0,canUnfreezeIn:0}}}async getSuperRepresentatives(){try{const e=await this.makeRpcCall("/wallet/listwitnesses",{},"POST");return e?.witnesses?e.witnesses.map((e,t)=>({address:e.address,name:e.url||`SR #${t+1}`,url:e.url||"",totalVotes:e.voteCount||0,totalProduced:e.totalProduced||0,ranking:t+1,productivity:e.totalProduced>0?e.totalProduced/(e.totalProduced+e.totalMissed||0)*100:0})).slice(0,27):this.getMockSuperRepresentatives()}catch(e){return this.getMockSuperRepresentatives()}}getMockSuperRepresentatives(){return[{address:"TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH",name:"Binance Staking",url:"https://binance.com",totalVotes:1615e7,totalProduced:15e5,ranking:1,productivity:99.5},{address:"TZ6p83xJA9kFZYRXfkKGgqwrqmFgDvbRds",name:"Poloniex",url:"https://poloniex.com",totalVotes:1452e7,totalProduced:145e4,ranking:2,productivity:99.2},{address:"TEVAq6pqDSNmE8Q8nC9qDQAA6VeF9Kux5Y",name:"TRONScan",url:"https://tronscan.org",totalVotes:128e8,totalProduced:142e4,ranking:3,productivity:99.8}]}async withdrawExpiredUnfrozen(){if(!this.account)throw new Error("Not connected");const e={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address},type_url:"type.googleapis.com/protocol.WithdrawExpireUnfreezeContract"},type:"WithdrawExpireUnfreezeContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`withdraw-${this.account.address}-${Date.now()}`)},t=await this.signTransaction(e,this.account.privateKey),n=await this.makeRpcCall("/wallet/broadcasttransaction",t);return n?.txid||e.txID}}},328:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TronDAppConnector=void 0;const a=n(360),s=n(940),r=n(848);t.TronDAppConnector=class{constructor(e){this.activeSessions=new Map,this.globalTronObject=null,this.currentUser=null,this.tronService=e,this.previewService=new r.TransactionPreviewService(e),this.initializeGlobalTronObject(),this.initializeDatabase()}async initializeDatabase(){try{await s.tronDatabase.initialize()}catch(e){console.warn("Database initialization failed, using snap state only:",e)}}initializeGlobalTronObject(){this.globalTronObject={isTronLink:!0,isMetaMaskTron:!0,ready:!0,request:this.handleDAppRequest.bind(this),isConnected:this.isConnected.bind(this),requestAccounts:()=>this.handleDAppRequest({method:"tron_requestAccounts"}),getAccount:()=>this.handleDAppRequest({method:"tron_getAccount"}),signMessage:e=>this.handleDAppRequest({method:"tron_signMessage",params:{message:e}}),signTransaction:e=>this.handleDAppRequest({method:"tron_signTransaction",params:e}),sendTransaction:e=>this.handleDAppRequest({method:"tron_sendTransaction",params:e}),chainId:728126428,networkVersion:"mainnet",on:this.addEventListener.bind(this),removeListener:this.removeEventListener.bind(this),selectedAddress:null,accounts:[]}}async connectDApp(e){try{if(!await this.showConnectionApproval(e))throw new Error("User rejected connection");const t=await this.tronService.getAccount();await this.ensureUserExists(t.address,t.network),await s.tronDatabase.storeDAppSession(this.currentUser.id,e.origin,e.name,e.icon,"mainnet"===t.network?728126428:2494104990);const n={connected:!0,origin:e.origin,name:e.name,icon:e.icon,accounts:[t.address],chainId:"mainnet"===t.network?728126428:2494104990,connectedAt:Date.now()};return this.activeSessions.set(e.origin,n),this.updateGlobalTronObject(t),await this.notifyUser(`Connected to ${e.name} successfully!`),n}catch(e){throw new Error(`Failed to connect dApp: ${e?.message||"Unknown error"}`)}}async ensureUserExists(e,t){this.currentUser||(this.currentUser=await s.tronDatabase.getUser(e),this.currentUser||(this.currentUser=await s.tronDatabase.storeUser(e,t)))}async handleDAppRequest(e){const{method:t,params:n,origin:a}=e;if(a&&!this.activeSessions.has(a))throw new Error("dApp not connected. Please connect first.");switch(t){case"tron_requestAccounts":return await this.requestAccounts();case"tron_getAccount":return await this.getAccount();case"tron_getBalance":return await this.getBalance();case"tron_signMessage":return await this.signMessage(n);case"tron_signTransaction":return await this.signTransaction(n);case"tron_sendTransaction":return await this.sendTransaction(n);case"tron_switchNetwork":return await this.switchNetwork(n);default:throw new Error(`Unsupported method: ${t}`)}}async requestAccounts(){try{return[(await this.tronService.getAccount()).address]}catch(e){throw new Error("Failed to get accounts")}}async getAccount(){return await this.tronService.getAccount()}async getBalance(){return await this.tronService.getBalance()}async signMessage(e){const{message:t}=e;if(!await this.showSigningApproval(t))throw new Error("User rejected message signing");return await this.tronService.signMessage(t)}async signTransaction(e){if(!await this.showTransactionApproval(e,"sign"))throw new Error("User rejected transaction signing");const t=await this.tronService.getAccount();return await this.tronService.signTransaction(e,t.privateKey)}async sendTransaction(e){if(!await this.showTransactionApproval(e,"send"))throw new Error("User rejected transaction");return await this.tronService.sendTransaction(e.to||e.to_address,e.amount||e.value,e.data)}async switchNetwork(e){await this.tronService.switchNetwork(e.network);for(const t of this.activeSessions.values())t.chainId="mainnet"===e.network?728126428:2494104990}isConnected(){return this.activeSessions.size>0}getActiveSessions(){return Array.from(this.activeSessions.values())}async disconnectDApp(e){this.activeSessions.delete(e),await this.notifyUser(`Disconnected from ${e}`)}async disconnectAll(){this.activeSessions.clear(),this.updateGlobalTronObject(null),await this.notifyUser("Disconnected from all dApps")}updateGlobalTronObject(e){this.globalTronObject&&(this.globalTronObject.selectedAddress=e?.address||null,this.globalTronObject.accounts=e?[e.address]:[],this.globalTronObject.chainId="mainnet"===e?.network?728126428:2494104990,this.globalTronObject.networkVersion=e?.network||"mainnet")}async showConnectionApproval(e){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("dApp Connection Request"),(0,a.text)(`**${e.name}** wants to connect to your TRON wallet.`),(0,a.divider)(),(0,a.text)("**Origin:**"),(0,a.text)(e.origin),(0,a.divider)(),(0,a.text)("This will allow the dApp to:"),(0,a.text)("â€¢ View your TRON address"),(0,a.text)("â€¢ Request transaction signatures"),(0,a.text)("â€¢ Send transaction requests"),(0,a.text)("â€¢ View your balance"),(0,a.divider)(),(0,a.text)("âš ï¸ Only connect to dApps you trust.")])}})}async showSigningApproval(e){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("Sign Message Request"),(0,a.text)("A dApp is requesting you to sign a message:"),(0,a.divider)(),(0,a.text)("**Message:**"),(0,a.copyable)(e),(0,a.divider)(),(0,a.text)("âš ï¸ Only sign messages you trust and understand.")])}})}async showTransactionApproval(e,t){const n=await this.tronService.getAccount(),s=e.to||e.to_address||"Unknown",r=e.value||e.amount||"0",o=await this.previewService.getNetworkStatus(n.network),i=await this.previewService.analyzeTransactionRisk(s,r,n.address),c=await this.previewService.simulateTransaction(s,r,n.address),d=await this.previewService.getContractDetails(s,e.data),l={from:n.address,to:s,amount:r,memo:e.data,estimatedFee:1,networkStatus:o,riskLevel:i,contractInteraction:d,simulationResult:c},u=await this.previewService.buildTransactionPreview(l),w=[(0,a.heading)(`ðŸ” ${"sign"===t?"Sign":"Send"} Transaction Request`),(0,a.text)(`**dApp:** ${this.activeSessions.get(e.origin)?.name||"Unknown"}`),(0,a.divider)(),...u];return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)(w)}})}addEventListener(e,t){console.log(`Event listener added for: ${e}`)}removeEventListener(e,t){console.log(`Event listener removed for: ${e}`)}async notifyUser(e){await snap.request({method:"snap_notify",params:{type:"inApp",message:e}})}}},360:e=>{e.exports=require("@metamask/snaps-ui")},484:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.i18n=t.I18nService=void 0;const a=n(64);class s{static getInstance(){return s.instance||(s.instance=new s),s.instance}constructor(){this.currentLanguage="en",this.initializeLanguage()}async initializeLanguage(){try{const e=await snap.request({method:"snap_manageState",params:{operation:"get"}}),t=e?.userLanguage;t&&"string"==typeof t&&this.isValidLanguage(t)?this.currentLanguage=t:this.currentLanguage=this.detectBrowserLanguage()}catch(e){console.error("Failed to initialize language:",e),this.currentLanguage="en"}}detectBrowserLanguage(){return"en"}isValidLanguage(e){return e in a.translations}getLanguage(){return this.currentLanguage}async setLanguage(e){if(!this.isValidLanguage(e))throw new Error(`Unsupported language: ${e}`);this.currentLanguage=e;try{const t=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...t,userLanguage:e}}})}catch(e){console.error("Failed to persist language preference:",e)}}t(e,t){const n=a.translations[this.currentLanguage],s=a.translations.en,r=n?.[e]||s?.[e]||e;return t&&"string"==typeof r?Object.entries(t).reduce((e,[t,n])=>e.replace(new RegExp(`{{${t}}}`,"g"),n),r):r}getAvailableLanguages(){return[{code:"en",name:"English"},{code:"zh",name:"ä¸­æ–‡"},{code:"es",name:"EspaÃ±ol"},{code:"fr",name:"FranÃ§ais"},{code:"ja",name:"æ—¥æœ¬èªž"}]}}t.I18nService=s,s.instance=null,t.i18n=s.getInstance()},576:e=>{e.exports=require("@metamask/key-tree")},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TransactionPreviewService=void 0;const a=n(360),s=n(116);t.TransactionPreviewService=class{constructor(e){this.tronService=e}async buildTransactionPreview(e){const t=[];return t.push((0,a.heading)("ðŸ” Transaction Preview"),(0,a.divider)()),t.push((0,a.text)("**ðŸ“¤ From:**"),(0,a.copyable)(e.from),(0,a.text)("**ðŸ“¥ To:**"),(0,a.copyable)(e.to),(0,a.text)("**ðŸ’° Amount:**"),(0,a.text)(`${e.amount} TRX`),(0,a.divider)()),e.memo&&t.push((0,a.text)("**ðŸ“ Memo:**"),(0,a.text)(e.memo),(0,a.divider)()),e.networkStatus&&t.push(...this.buildNetworkStatus(e.networkStatus)),e.riskLevel&&t.push(...this.buildRiskAssessment(e.riskLevel)),t.push(...this.buildFeeEstimation(e.estimatedFee||(0,s.calculateTxFee)())),e.contractInteraction?.isContract&&t.push(...this.buildContractDetails(e.contractInteraction)),e.simulationResult&&t.push(...this.buildSimulationResults(e.simulationResult)),t.push((0,a.divider)(),(0,a.text)("**ðŸ“Š Transaction Summary:**"),(0,a.text)(`â€¢ Total Cost: ${(parseFloat(e.amount)+(e.estimatedFee||(0,s.calculateTxFee)())).toFixed(6)} TRX`),(0,a.text)(`â€¢ Network: ${e.networkStatus?.networkName||"Unknown"}`),(0,a.text)(`â€¢ Risk Level: ${this.getRiskEmoji(e.riskLevel?.level)} ${e.riskLevel?.level||"Unknown"}`)),t}buildNetworkStatus(e){return[(0,a.text)("**ðŸŒ Network Status:**"),(0,a.text)(`â€¢ Congestion: ${{low:"ðŸŸ¢",medium:"ðŸŸ¡",high:"ðŸ”´"}[e.congestion]} ${e.congestion}`),(0,a.text)(`â€¢ Block Height: ${e.currentBlock.toLocaleString()}`),(0,a.text)(`â€¢ Avg Block Time: ${e.averageBlockTime}s`),(0,a.divider)()]}buildRiskAssessment(e){const t=[(0,a.text)(`**âš ï¸ Risk Assessment: ${this.getRiskEmoji(e.level)} ${e.level.toUpperCase()}**`),(0,a.text)(`Risk Score: ${e.score}/100`)];return e.warnings.length>0&&(t.push((0,a.text)("**Warnings:**")),e.warnings.forEach(e=>{t.push((0,a.text)(`â€¢ ${e}`))})),t.push((0,a.divider)()),t}buildFeeEstimation(e){return[(0,a.text)("**â›½ Fee Estimation:**"),(0,a.text)(`â€¢ Base Fee: ${e} TRX`),(0,a.text)("â€¢ Energy: Included"),(0,a.text)("â€¢ Bandwidth: Included"),(0,a.divider)()]}buildContractDetails(e){return[(0,a.text)("**ðŸ“„ Smart Contract Interaction:**"),(0,a.text)(`â€¢ Type: ${e.contractType||"Unknown"}`),(0,a.text)(`â€¢ Method: ${e.method||"Unknown"}`),(0,a.divider)()]}buildSimulationResults(e){const t=[(0,a.text)("**ðŸ§ª Simulation Results:**"),(0,a.text)("â€¢ Status: "+(e.success?"âœ… Success":"âŒ Failed"))];return e.success?(void 0!==e.energyUsed&&t.push((0,a.text)(`â€¢ Energy Used: ${e.energyUsed.toLocaleString()}`)),void 0!==e.bandwidthUsed&&t.push((0,a.text)(`â€¢ Bandwidth Used: ${e.bandwidthUsed.toLocaleString()}`))):e.error&&t.push((0,a.text)(`â€¢ Error: ${e.error}`)),t.push((0,a.divider)()),t}getRiskEmoji(e){switch(e){case"low":return"ðŸŸ¢";case"medium":return"ðŸŸ¡";case"high":return"ðŸ”´";default:return"âšª"}}async analyzeTransactionRisk(e,t,n){const a=[];let r=0;(0,s.validateTronAddress)(e)||(a.push("Invalid recipient address format"),r+=50),await this.isNewAddress(e)&&(a.push("First transaction to this address"),r+=20);const o=await this.tronService.getBalance(),i=parseFloat(t)/parseFloat((0,s.formatTrx)(o))*100;let c;return i>50&&(a.push(`Sending ${i.toFixed(0)}% of your balance`),r+=30),await this.isContractAddress(e)&&(a.push("Recipient is a smart contract"),r+=15),c=r>=60?"high":r>=30?"medium":"low",{level:c,warnings:a,score:r}}async getNetworkStatus(e){try{return{congestion:"low",averageBlockTime:3,currentBlock:12345678,networkName:"mainnet"===e?"TRON Mainnet":"TRON Testnet (Shasta)"}}catch(t){return{congestion:"medium",averageBlockTime:3,currentBlock:0,networkName:e}}}async simulateTransaction(e,t,n){try{const n=(0,s.validateTronAddress)(e),a=await this.checkSufficientBalance(t);return n?a?{success:!0,energyUsed:5e3,bandwidthUsed:200}:{success:!1,error:"Insufficient balance"}:{success:!1,error:"Invalid recipient address"}}catch(e){return{success:!1,error:e.message||"Simulation failed"}}}async isNewAddress(e){return!1}async isContractAddress(e){return e.startsWith("TR")||e.startsWith("TE")}async checkSufficientBalance(e){const t=await this.tronService.getBalance(),n=parseFloat(e)+(0,s.calculateTxFee)();return parseFloat((0,s.formatTrx)(t))>=n}async getContractDetails(e,t){return await this.isContractAddress(e)?{isContract:!0,contractType:"TRC20",method:"transfer",params:t}:{isContract:!1}}}},940:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tronDatabase=t.TronDatabaseService=void 0;class n{static getInstance(){return n.instance||(n.instance=new n),n.instance}constructor(){this.isInitialized=!1}async initialize(){if(!this.isInitialized)try{await this.testConnection(),this.isInitialized=!0}catch(e){console.warn("Database not available, using snap state storage only:",e),this.isInitialized=!1}}async testConnection(){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL not available")}async storeUser(e,t){const n={id:Date.now(),address:e,network:t,createdAt:(new Date).toISOString()};try{return this.isInitialized,await this.storeInSnapState("user",n),n}catch(e){throw console.error("Failed to store user:",e),e}}async getUser(e){try{return this.isInitialized,await this.getFromSnapState("user")}catch(e){return console.error("Failed to get user:",e),null}}async storeDAppSession(e,t,n,a,s){const r={id:Date.now(),userId:e,origin:t,name:n,icon:a,chainId:s,isActive:!0,connectedAt:(new Date).toISOString(),lastAccessAt:(new Date).toISOString()};try{const n=(await this.getDAppSessions(e)).map(e=>e.origin===t?{...e,isActive:!1}:e);return n.push(r),await this.storeInSnapState("dappSessions",n),r}catch(e){throw console.error("Failed to store dApp session:",e),e}}async getDAppSessions(e){try{return(await this.getFromSnapState("dappSessions")||[]).filter(t=>t.userId===e)}catch(e){return console.error("Failed to get dApp sessions:",e),[]}}async getActiveDAppSessions(e){return(await this.getDAppSessions(e)).filter(e=>e.isActive)}async deactivateDAppSession(e,t){try{const n=(await this.getDAppSessions(e)).map(e=>e.origin===t?{...e,isActive:!1}:e);await this.storeInSnapState("dappSessions",n)}catch(e){console.error("Failed to deactivate dApp session:",e)}}async deactivateAllDAppSessions(e){try{const t=(await this.getDAppSessions(e)).map(e=>({...e,isActive:!1}));await this.storeInSnapState("dappSessions",t)}catch(e){console.error("Failed to deactivate all dApp sessions:",e)}}async storeTransaction(e,t,n,a,s,r,o,i,c){const d={id:Date.now(),userId:e,sessionId:t,txId:n,type:a,amount:s,toAddress:r,fromAddress:o,status:"pending",network:i,metadata:c,createdAt:(new Date).toISOString()};try{const t=await this.getTransactions(e);return t.unshift(d),t.length>100&&t.splice(100),await this.storeInSnapState("transactions",t),d}catch(e){throw console.error("Failed to store transaction:",e),e}}async getTransactions(e,t=50){try{return(await this.getFromSnapState("transactions")||[]).filter(t=>t.userId===e).slice(0,t)}catch(e){return console.error("Failed to get transactions:",e),[]}}async updateTransactionStatus(e,t){try{const n=(await this.getFromSnapState("transactions")||[]).map(n=>n.txId===e?{...n,status:t,confirmedAt:"confirmed"===t?(new Date).toISOString():n.confirmedAt}:n);await this.storeInSnapState("transactions",n)}catch(e){console.error("Failed to update transaction status:",e)}}async storeSignedMessage(e,t,n,a,s){const r={id:Date.now(),userId:e,sessionId:t,message:n,signature:a,messageHash:s,createdAt:(new Date).toISOString()};try{const t=await this.getSignedMessages(e);return t.unshift(r),t.length>50&&t.splice(50),await this.storeInSnapState("signedMessages",t),r}catch(e){throw console.error("Failed to store signed message:",e),e}}async getSignedMessages(e,t=25){try{return(await this.getFromSnapState("signedMessages")||[]).filter(t=>t.userId===e).slice(0,t)}catch(e){return console.error("Failed to get signed messages:",e),[]}}async storeInSnapState(e,t){const n=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...n,[e]:t}}})}async getFromSnapState(e){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});return t?.[e]}}t.TronDatabaseService=n,n.instance=null,t.tronDatabase=n.getInstance()}},t={};function n(a){var s=t[a];if(void 0!==s)return s.exports;var r=t[a]={exports:{}};return e[a](r,r.exports,n),r.exports}var a={};(()=>{var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.onRpcRequest=void 0;const t=n(360),s=n(218),r=n(328),o=n(116),i=n(848),c=n(484),d=new s.TronService,l=new i.TransactionPreviewService(d),u=new r.TronDAppConnector(d);e.onRpcRequest=async({origin:e,request:n})=>{try{switch(n.method){case"tron_connect":return await async function(){try{const e=await d.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)(c.i18n.t("connection.title")),(0,t.text)(c.i18n.t("connection.description")),(0,t.divider)(),(0,t.text)(c.i18n.t("connection.accountAddress")),(0,t.copyable)(e.address),(0,t.text)(c.i18n.t("connection.network")),(0,t.text)(e.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:c.i18n.t("connection.success")}}),e;throw new Error(c.i18n.t("connection.rejected"))}catch(e){throw new Error(`${c.i18n.t("connection.failed")}: ${e?.message||c.i18n.t("error.unknown")}`)}}();case"tron_getAccount":return await async function(){try{return await d.getAccount()}catch(e){throw new Error(`Failed to get account: ${e?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const e=await d.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("TRON Balance"),(0,t.text)(`**Balance:** ${(0,o.formatTrx)(e)} TRX`)])}}),{balance:(0,o.formatTrx)(e),unit:"TRX"}}catch(e){throw new Error(`Failed to get balance: ${e?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(e){try{const{to:n,amount:a,memo:s}=e;if(!(0,o.validateTronAddress)(n))throw new Error(c.i18n.t("transaction.invalidAddress"));if(!a||parseFloat(a)<=0)throw new Error(c.i18n.t("transaction.invalidAmount"));const r=await d.getAccount(),i=await d.getBalance();if(parseFloat(a)>parseFloat((0,o.formatTrx)(i)))throw new Error(c.i18n.t("transaction.insufficientBalance"));const u=await l.getNetworkStatus(r.network),w=await l.analyzeTransactionRisk(n,a,r.address),p=await l.simulateTransaction(n,a,r.address),g=await l.getContractDetails(n),m={from:r.address,to:n,amount:a,memo:s,estimatedFee:1,networkStatus:u,riskLevel:w,contractInteraction:g,simulationResult:p},h=await l.buildTransactionPreview(m);if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)(h)}}))throw new Error("Transaction cancelled by user");const v=await d.sendTransaction(n,a,s);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${v}`}}),{txHash:v,status:"pending"}}catch(e){throw new Error(`Transaction failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_signMessage":return await async function(e){try{const{message:n}=e;if(!n)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Sign Message"),(0,t.text)("**Message to sign:**"),(0,t.text)(n),(0,t.divider)(),(0,t.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await d.signMessage(n)}}catch(e){throw new Error(`Message signing failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getTransactionHistory":return await async function(){try{const e=await d.getTransactionHistory();if(0===e.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Transaction History"),(0,t.text)("No transactions found.")])}});else{const n=e.slice(0,5).map(e=>[(0,t.text)(`**${e.type}** - ${(0,o.formatTrx)(e.amount)} TRX`),(0,t.text)(`To: ${e.to}`),(0,t.text)(`${new Date(e.timestamp).toLocaleDateString()}`),(0,t.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Recent Transactions"),...n])}})}return e}catch(e){throw new Error(`Failed to get transaction history: ${e?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(e){try{const{network:n}=e;if(!["mainnet","testnet"].includes(n))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Switch TRON Network"),(0,t.text)(`Switch to TRON ${n}?`),(0,t.divider)(),(0,t.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await d.switchNetwork(n),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${n}`}}),{network:n}}catch(e){throw new Error(`Failed to switch network: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_connect":return await async function(e){try{const{origin:t,name:n,icon:a}=e||{};if(!t||!n)throw new Error("dApp origin and name are required");const s=await u.connectDApp({origin:t,name:n,icon:a});return{connected:!0,session:{accounts:s.accounts,chainId:s.chainId,origin:s.origin,name:s.name}}}catch(e){throw new Error(`Failed to connect dApp: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_sessions":return await async function(){try{const e=u.getActiveSessions();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Active dApp Connections"),...0===e.length?[(0,t.text)("No active dApp connections.")]:e.map(e=>[(0,t.text)(`**${e.name}**`),(0,t.text)(`Origin: ${e.origin}`),(0,t.text)(`Connected: ${new Date(e.connectedAt).toLocaleString()}`),(0,t.divider)()]).flat()])}}),{sessions:e}}catch(e){throw new Error(`Failed to get sessions: ${e?.message||"Unknown error"}`)}}();case"tron_dapp_disconnect":return await async function(e){try{const{origin:t,all:n}=e||{};if(n)await u.disconnectAll();else{if(!t)throw new Error("Must specify origin or all=true");await u.disconnectDApp(t)}return{disconnected:!0}}catch(e){throw new Error(`Failed to disconnect: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_stake":return await async function(e){try{const{amount:n,resource:a="ENERGY"}=e;if(!n||parseFloat(n)<=0)throw new Error("Invalid staking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Stake TRX"),(0,t.text)(`You are about to stake **${(0,o.formatTrx)(n)} TRX** for **${a}**.`),(0,t.divider)(),(0,t.text)("**Staking Details:**"),(0,t.text)(`â€¢ Resource: ${a}`),(0,t.text)("â€¢ Lock Period: 3 days"),(0,t.text)("â€¢ You can unstake anytime, but need to wait 14 days to withdraw"),(0,t.divider)(),(0,t.text)("**Benefits:**"),(0,t.text)("â€¢ Earn voting rights (1 TRX = 1 vote)"),(0,t.text)(`â€¢ Get free ${a.toLowerCase()} for transactions`),(0,t.text)("â€¢ Support the TRON network")])}}))throw new Error("Staking cancelled by user");const s=await d.stakeTRX(n,a);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully staked ${(0,o.formatTrx)(n)} TRX for ${a}`}}),{txHash:s,amount:n,resource:a}}catch(e){throw new Error(`Staking failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_unstake":return await async function(e){try{const{amount:n,resource:a="ENERGY"}=e;if(!n||parseFloat(n)<=0)throw new Error("Invalid unstaking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Unstake TRX"),(0,t.text)(`You are about to unstake **${(0,o.formatTrx)(n)} TRX** from **${a}**.`),(0,t.divider)(),(0,t.text)("**Important:**"),(0,t.text)("â€¢ Unstaked TRX will be locked for 14 days"),(0,t.text)("â€¢ You will lose voting rights for this amount"),(0,t.text)(`â€¢ Free ${a.toLowerCase()} will be reduced`),(0,t.divider)(),(0,t.text)("Are you sure you want to continue?")])}}))throw new Error("Unstaking cancelled by user");const s=await d.unstakeTRX(n,a);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully unstaked ${(0,o.formatTrx)(n)} TRX. Available for withdrawal in 14 days.`}}),{txHash:s,amount:n,resource:a}}catch(e){throw new Error(`Unstaking failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_vote":return await async function(e){try{const{votes:n}=e;if(!n||!Array.isArray(n)||0===n.length)throw new Error("Invalid votes parameter");const a=n.reduce((e,t)=>e+(t.count||0),0),s=await d.getStakingInfo(),r=Math.floor(s.frozen);if(a>r)throw new Error(`Insufficient voting power. You have ${r} votes available.`);const o=n.map(e=>[(0,t.text)(`â€¢ ${e.name||e.address.substring(0,10)+"..."}: **${e.count} votes**`)]).flat();if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Vote for Super Representatives"),(0,t.text)(`Total Votes: **${a}** / ${r} available`),(0,t.divider)(),(0,t.text)("**Your Votes:**"),...o,(0,t.divider)(),(0,t.text)("**Note:**"),(0,t.text)("â€¢ Votes are updated every 6 hours"),(0,t.text)("â€¢ You can change votes anytime"),(0,t.text)("â€¢ Voting helps secure the network")])}}))throw new Error("Voting cancelled by user");const i=await d.voteForSR(n);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully voted for ${n.length} Super Representative(s)`}}),{txHash:i,votes:n.length,totalVotes:a}}catch(e){throw new Error(`Voting failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getStakingInfo":return await async function(){try{const e=await d.getStakingInfo(),n=e.votes.length>0?e.votes.map(e=>(0,t.text)(`â€¢ ${e.name}: ${e.votes} votes`)):[(0,t.text)("No active votes")];return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Staking Information"),(0,t.divider)(),(0,t.text)("**Staked Balance:**"),(0,t.text)(`â€¢ Total: ${(0,o.formatTrx)(e.frozen.toString())} TRX`),(0,t.text)(`â€¢ For Energy: ${(0,o.formatTrx)(e.frozenEnergy.toString())} TRX`),(0,t.text)(`â€¢ For Bandwidth: ${(0,o.formatTrx)(e.frozenBandwidth.toString())} TRX`),(0,t.divider)(),(0,t.text)("**Voting Power:**"),(0,t.text)(`â€¢ Available: ${Math.floor(e.frozen)} votes`),(0,t.divider)(),(0,t.text)("**Active Votes:**"),...n,(0,t.divider)(),(0,t.text)(`**Rewards:** ${(0,o.formatTrx)(e.rewards.toString())} TRX`)])}}),e}catch(e){throw new Error(`Failed to get staking info: ${e?.message||"Unknown error"}`)}}();case"tron_getSuperRepresentatives":return await async function(){try{const e=await d.getSuperRepresentatives(),n=e.slice(0,5).map(e=>[(0,t.text)(`**#${e.ranking} ${e.name}**`),(0,t.text)(`Votes: ${(e.totalVotes/1e6).toFixed(2)}M`),(0,t.text)(`Productivity: ${e.productivity.toFixed(1)}%`),(0,t.divider)()]).flat();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Top Super Representatives"),(0,t.text)("Vote for SRs to earn rewards and support the network"),(0,t.divider)(),...n,(0,t.text)("... and more")])}}),e}catch(e){throw new Error(`Failed to get Super Representatives: ${e?.message||"Unknown error"}`)}}();case"tron_withdrawExpiredUnfrozen":return await async function(){try{if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Withdraw Unfrozen Balance"),(0,t.text)("Withdraw any TRX that has completed the 14-day unstaking period."),(0,t.divider)(),(0,t.text)("This will transfer all available unfrozen TRX back to your account.")])}}))throw new Error("Withdrawal cancelled by user");const e=await d.withdrawExpiredUnfrozen();return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully withdrew unfrozen balance"}}),{txHash:e}}catch(e){throw new Error(`Withdrawal failed: ${e?.message||"Unknown error"}`)}}();case"tron_setLanguage":return await async function(e){try{const{language:t}=e,n=c.i18n.getAvailableLanguages().map(e=>e.code);if(!n.includes(t))throw new Error(`Invalid language. Supported: ${n.join(", ")}`);return await c.i18n.setLanguage(t),await snap.request({method:"snap_notify",params:{type:"inApp",message:c.i18n.t("common.success")}}),{language:t,success:!0}}catch(e){throw new Error(`Failed to set language: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getLanguage":return await async function(){try{return{current:c.i18n.getLanguage(),available:c.i18n.getAvailableLanguages()}}catch(e){throw new Error(`Failed to get language: ${e?.message||"Unknown error"}`)}}();default:throw new Error(`Method ${n.method} not supported`)}}catch(e){throw console.error("RPC request error:",e),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${e?.message||"Unknown error"}`}}),e}}})();var s=exports;for(var r in a)s[r]=a[r];a.__esModule&&Object.defineProperty(s,"__esModule",{value:!0})})();