(()=>{"use strict";var t={185:(t,e)=>{function n(t){return!(!t||"string"!=typeof t)&&/^T[A-Za-z0-9]{33}$/.test(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.validateTronAddress=n,e.formatTrx=function(t){return(("string"==typeof t?parseFloat(t):t)/1e6).toFixed(6)},e.trxToSun=function(t){const e="string"==typeof t?parseFloat(t):t;return Math.floor(1e6*e)},e.truncateAddress=function(t,e=6,n=4){return!t||t.length<=e+n?t:`${t.slice(0,e)}...${t.slice(-n)}`},e.formatTimestamp=function(t){return new Date(t).toLocaleString()},e.validateAmount=function(t){if(!t||"string"!=typeof t)return!1;const e=parseFloat(t);return!isNaN(e)&&e>0&&e<=1e6},e.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},e.parseErrorMessage=function(t){return"string"==typeof t?t:t?.message?t.message:t?.error?t.error:"An unknown error occurred"},e.validateNetwork=function(t){return"mainnet"===t||"testnet"===t},e.formatBalance=function(t,e=6){return t.toFixed(e).replace(/\.?0+$/,"")},e.isValidTronAddress=function(t){return n(t)&&34===t.length},e.sanitizeInput=function(t){return"string"!=typeof t?"":t.trim().replace(/[<>]/g,"")},e.calculateTxFee=function(){return 1},e.checkSufficientBalance=function(t,e){return e>=parseFloat(t)+1}},283:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronDAppConnector=void 0;const a=n(360),r=n(379);e.TronDAppConnector=class{constructor(t){this.activeSessions=new Map,this.globalTronObject=null,this.currentUser=null,this.tronService=t,this.initializeGlobalTronObject(),this.initializeDatabase()}async initializeDatabase(){try{await r.tronDatabase.initialize()}catch(t){console.warn("Database initialization failed, using snap state only:",t)}}initializeGlobalTronObject(){this.globalTronObject={isTronLink:!0,isMetaMaskTron:!0,ready:!0,request:this.handleDAppRequest.bind(this),isConnected:this.isConnected.bind(this),requestAccounts:()=>this.handleDAppRequest({method:"tron_requestAccounts"}),getAccount:()=>this.handleDAppRequest({method:"tron_getAccount"}),signMessage:t=>this.handleDAppRequest({method:"tron_signMessage",params:{message:t}}),signTransaction:t=>this.handleDAppRequest({method:"tron_signTransaction",params:t}),sendTransaction:t=>this.handleDAppRequest({method:"tron_sendTransaction",params:t}),chainId:728126428,networkVersion:"mainnet",on:this.addEventListener.bind(this),removeListener:this.removeEventListener.bind(this),selectedAddress:null,accounts:[]}}async connectDApp(t){try{if(!await this.showConnectionApproval(t))throw new Error("User rejected connection");const e=await this.tronService.getAccount();await this.ensureUserExists(e.address,e.network),await r.tronDatabase.storeDAppSession(this.currentUser.id,t.origin,t.name,t.icon,"mainnet"===e.network?728126428:2494104990);const n={connected:!0,origin:t.origin,name:t.name,icon:t.icon,accounts:[e.address],chainId:"mainnet"===e.network?728126428:2494104990,connectedAt:Date.now()};return this.activeSessions.set(t.origin,n),this.updateGlobalTronObject(e),await this.notifyUser(`Connected to ${t.name} successfully!`),n}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}async ensureUserExists(t,e){this.currentUser||(this.currentUser=await r.tronDatabase.getUser(t),this.currentUser||(this.currentUser=await r.tronDatabase.storeUser(t,e)))}async handleDAppRequest(t){const{method:e,params:n,origin:a}=t;if(a&&!this.activeSessions.has(a))throw new Error("dApp not connected. Please connect first.");switch(e){case"tron_requestAccounts":return await this.requestAccounts();case"tron_getAccount":return await this.getAccount();case"tron_getBalance":return await this.getBalance();case"tron_signMessage":return await this.signMessage(n);case"tron_signTransaction":return await this.signTransaction(n);case"tron_sendTransaction":return await this.sendTransaction(n);case"tron_switchNetwork":return await this.switchNetwork(n);default:throw new Error(`Unsupported method: ${e}`)}}async requestAccounts(){try{return[(await this.tronService.getAccount()).address]}catch(t){throw new Error("Failed to get accounts")}}async getAccount(){return await this.tronService.getAccount()}async getBalance(){return await this.tronService.getBalance()}async signMessage(t){const{message:e}=t;if(!await this.showSigningApproval(e))throw new Error("User rejected message signing");return await this.tronService.signMessage(e)}async signTransaction(t){if(!await this.showTransactionApproval(t,"sign"))throw new Error("User rejected transaction signing");const e=await this.tronService.getAccount();return await this.tronService.signTransaction(t,e.privateKey)}async sendTransaction(t){if(!await this.showTransactionApproval(t,"send"))throw new Error("User rejected transaction");return await this.tronService.sendTransaction(t.to||t.to_address,t.amount||t.value,t.data)}async switchNetwork(t){await this.tronService.switchNetwork(t.network);for(const e of this.activeSessions.values())e.chainId="mainnet"===t.network?728126428:2494104990}isConnected(){return this.activeSessions.size>0}getActiveSessions(){return Array.from(this.activeSessions.values())}async disconnectDApp(t){this.activeSessions.delete(t),await this.notifyUser(`Disconnected from ${t}`)}async disconnectAll(){this.activeSessions.clear(),this.updateGlobalTronObject(null),await this.notifyUser("Disconnected from all dApps")}updateGlobalTronObject(t){this.globalTronObject&&(this.globalTronObject.selectedAddress=t?.address||null,this.globalTronObject.accounts=t?[t.address]:[],this.globalTronObject.chainId="mainnet"===t?.network?728126428:2494104990,this.globalTronObject.networkVersion=t?.network||"mainnet")}async showConnectionApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("dApp Connection Request"),(0,a.text)(`**${t.name}** wants to connect to your TRON wallet.`),(0,a.divider)(),(0,a.text)("**Origin:**"),(0,a.text)(t.origin),(0,a.divider)(),(0,a.text)("This will allow the dApp to:"),(0,a.text)("• View your TRON address"),(0,a.text)("• Request transaction signatures"),(0,a.text)("• Send transaction requests"),(0,a.text)("• View your balance"),(0,a.divider)(),(0,a.text)("⚠️ Only connect to dApps you trust.")])}})}async showSigningApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("Sign Message Request"),(0,a.text)("A dApp is requesting you to sign a message:"),(0,a.divider)(),(0,a.text)("**Message:**"),(0,a.copyable)(t),(0,a.divider)(),(0,a.text)("⚠️ Only sign messages you trust and understand.")])}})}async showTransactionApproval(t,e){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)(("sign"===e?"Sign":"Send")+" Transaction"),(0,a.text)(`A dApp is requesting to ${e} a transaction:`),(0,a.divider)(),(0,a.text)("**To:**"),(0,a.copyable)(t.to||t.to_address||"Unknown"),(0,a.text)("**Amount:**"),(0,a.text)(`${t.value||t.amount||"0"} TRX`),...t.data?[(0,a.text)("**Data:**"),(0,a.text)(String(t.data).substring(0,100)+(String(t.data).length>100?"...":""))]:[],(0,a.divider)(),(0,a.text)("**Estimated Fee:** ~1 TRX")])}})}addEventListener(t,e){console.log(`Event listener added for: ${t}`)}removeEventListener(t,e){console.log(`Event listener removed for: ${t}`)}async notifyUser(t){await snap.request({method:"snap_notify",params:{type:"inApp",message:t}})}}},360:t=>{t.exports=require("@metamask/snaps-ui")},379:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tronDatabase=e.TronDatabaseService=void 0;class n{static getInstance(){return n.instance||(n.instance=new n),n.instance}constructor(){this.isInitialized=!1}async initialize(){if(!this.isInitialized)try{await this.testConnection(),this.isInitialized=!0}catch(t){console.warn("Database not available, using snap state storage only:",t),this.isInitialized=!1}}async testConnection(){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL not available")}async storeUser(t,e){const n={id:Date.now(),address:t,network:e,createdAt:(new Date).toISOString()};try{return this.isInitialized,await this.storeInSnapState("user",n),n}catch(t){throw console.error("Failed to store user:",t),t}}async getUser(t){try{return this.isInitialized,await this.getFromSnapState("user")}catch(t){return console.error("Failed to get user:",t),null}}async storeDAppSession(t,e,n,a,r){const s={id:Date.now(),userId:t,origin:e,name:n,icon:a,chainId:r,isActive:!0,connectedAt:(new Date).toISOString(),lastAccessAt:(new Date).toISOString()};try{const n=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);return n.push(s),await this.storeInSnapState("dappSessions",n),s}catch(t){throw console.error("Failed to store dApp session:",t),t}}async getDAppSessions(t){try{return(await this.getFromSnapState("dappSessions")||[]).filter(e=>e.userId===t)}catch(t){return console.error("Failed to get dApp sessions:",t),[]}}async getActiveDAppSessions(t){return(await this.getDAppSessions(t)).filter(t=>t.isActive)}async deactivateDAppSession(t,e){try{const n=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);await this.storeInSnapState("dappSessions",n)}catch(t){console.error("Failed to deactivate dApp session:",t)}}async deactivateAllDAppSessions(t){try{const e=(await this.getDAppSessions(t)).map(t=>({...t,isActive:!1}));await this.storeInSnapState("dappSessions",e)}catch(t){console.error("Failed to deactivate all dApp sessions:",t)}}async storeTransaction(t,e,n,a,r,s,o,i,c){const d={id:Date.now(),userId:t,sessionId:e,txId:n,type:a,amount:r,toAddress:s,fromAddress:o,status:"pending",network:i,metadata:c,createdAt:(new Date).toISOString()};try{const e=await this.getTransactions(t);return e.unshift(d),e.length>100&&e.splice(100),await this.storeInSnapState("transactions",e),d}catch(t){throw console.error("Failed to store transaction:",t),t}}async getTransactions(t,e=50){try{return(await this.getFromSnapState("transactions")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get transactions:",t),[]}}async updateTransactionStatus(t,e){try{const n=(await this.getFromSnapState("transactions")||[]).map(n=>n.txId===t?{...n,status:e,confirmedAt:"confirmed"===e?(new Date).toISOString():n.confirmedAt}:n);await this.storeInSnapState("transactions",n)}catch(t){console.error("Failed to update transaction status:",t)}}async storeSignedMessage(t,e,n,a,r){const s={id:Date.now(),userId:t,sessionId:e,message:n,signature:a,messageHash:r,createdAt:(new Date).toISOString()};try{const e=await this.getSignedMessages(t);return e.unshift(s),e.length>50&&e.splice(50),await this.storeInSnapState("signedMessages",e),s}catch(t){throw console.error("Failed to store signed message:",t),t}}async getSignedMessages(t,e=25){try{return(await this.getFromSnapState("signedMessages")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get signed messages:",t),[]}}async storeInSnapState(t,e){const n=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...n,[t]:e}}})}async getFromSnapState(t){const e=await snap.request({method:"snap_manageState",params:{operation:"get"}});return e?.[t]}}e.TronDatabaseService=n,n.instance=null,e.tronDatabase=n.getInstance()},576:t=>{t.exports=require("@metamask/key-tree")},701:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronService=void 0;const a=n(576);e.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const t=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),e=await(0,a.getBIP44AddressKeyDeriver)(t),n=await e(195),r=this.privateKeyToAddress(n.privateKey||"");return this.account={address:r,privateKey:n.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(t){throw new Error(`Failed to connect: ${t?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!t?.tronAccount)throw new Error("No account found. Please connect first.");this.account=t.tronAccount}return this.account}async getBalance(){const t=await this.getAccount();try{const e=await this.makeRpcCall("wallet/getaccount",{address:t.address,visible:!0});return e?.balance?e.balance/1e6:0}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}async sendTransaction(t,e,n){const a=await this.getAccount();try{const n={to_address:t,owner_address:a.address,amount:Math.floor(1e6*parseFloat(e)),visible:!0},r=await this.makeRpcCall("wallet/createtransaction",n);if(!r?.txID)throw new Error("Failed to create transaction");const s=await this.signTransaction(r,a.privateKey),o=await this.makeRpcCall("wallet/broadcasttransaction",s);if(!o?.result)throw new Error(o?.message||"Transaction broadcast failed");return r.txID}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}async signMessage(t){const e=await this.getAccount();try{const n=Buffer.from(t,"utf8").toString("hex");return await this.signHex(n,e.privateKey)}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}async getTransactionHistory(){const t=await this.getAccount();try{const e=await this.makeRpcCall("v1/accounts/"+t.address+"/transactions",null,"GET");return e?.data?e.data.map(t=>({txId:t.txID||"",type:this.getTransactionType(t.raw_data?.contract?.[0]?.type||""),amount:(t.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:t.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:t.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:t.block_timestamp||0,status:t.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(t){return[]}}async switchNetwork(t){this.network=t,this.account&&(this.account.network=t,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(t,e,n="POST"){const a="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",r={method:n,headers:{"Content-Type":"application/json"}};e&&"POST"===n&&(r.body=JSON.stringify(e));const s=await fetch(`${a}/${t}`,r);if(!s.ok)throw new Error(`RPC call failed: ${s.statusText}`);return await s.json()}privateKeyToAddress(t){return"T"+this.simpleHash(t).slice(0,33)}simpleHash(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e&=e;return Math.abs(e).toString(16).padStart(33,"0")}async signTransaction(t,e){const n=await this.signHex(t.txID,e);return{...t,signature:[n]}}async signHex(t,e){return this.simpleHash(t+e)}getTransactionType(t){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract"}[t]||"Unknown"}}}},e={};function n(a){var r=e[a];if(void 0!==r)return r.exports;var s=e[a]={exports:{}};return t[a](s,s.exports,n),s.exports}var a={};(()=>{var t=a;Object.defineProperty(t,"__esModule",{value:!0}),t.onRpcRequest=void 0;const e=n(360),r=n(701),s=n(283),o=n(185),i=new r.TronService,c=new s.TronDAppConnector(i);t.onRpcRequest=async({origin:t,request:n})=>{try{switch(n.method){case"tron_connect":return await async function(){try{const t=await i.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Connect to TRON Network"),(0,e.text)("This will create a TRON account derived from your MetaMask seed phrase."),(0,e.divider)(),(0,e.text)("**Account Address:**"),(0,e.copyable)(t.address),(0,e.text)("**Network:**"),(0,e.text)(t.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully connected to TRON network!"}}),t;throw new Error("User rejected connection")}catch(t){throw new Error(`Failed to connect to TRON: ${t?.message||"Unknown error"}`)}}();case"tron_getAccount":return await async function(){try{return await i.getAccount()}catch(t){throw new Error(`Failed to get account: ${t?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const t=await i.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("TRON Balance"),(0,e.text)(`**Balance:** ${(0,o.formatTrx)(t)} TRX`)])}}),{balance:(0,o.formatTrx)(t),unit:"TRX"}}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(t){try{const{to:n,amount:a,memo:r}=t;if(!(0,o.validateTronAddress)(n))throw new Error("Invalid TRON address");if(!a||parseFloat(a)<=0)throw new Error("Invalid amount");const s=await i.getAccount(),c=await i.getBalance();if(parseFloat(a)>parseFloat((0,o.formatTrx)(c)))throw new Error("Insufficient balance");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Confirm TRON Transaction"),(0,e.text)("**From:**"),(0,e.copyable)(s.address),(0,e.text)("**To:**"),(0,e.copyable)(n),(0,e.text)("**Amount:**"),(0,e.text)(`${a} TRX`),...r?[(0,e.text)("**Memo:**"),(0,e.text)(r)]:[],(0,e.divider)(),(0,e.text)("**Network Fee:** ~1 TRX"),(0,e.text)("**Total:** ~"+(parseFloat(a)+1).toString()+" TRX")])}}))throw new Error("Transaction cancelled by user");const d=await i.sendTransaction(n,a,r);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${d}`}}),{txHash:d,status:"pending"}}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_signMessage":return await async function(t){try{const{message:n}=t;if(!n)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Sign Message"),(0,e.text)("**Message to sign:**"),(0,e.text)(n),(0,e.divider)(),(0,e.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await i.signMessage(n)}}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_getTransactionHistory":return await async function(){try{const t=await i.getTransactionHistory();if(0===t.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Transaction History"),(0,e.text)("No transactions found.")])}});else{const n=t.slice(0,5).map(t=>[(0,e.text)(`**${t.type}** - ${(0,o.formatTrx)(t.amount)} TRX`),(0,e.text)(`To: ${t.to}`),(0,e.text)(`${new Date(t.timestamp).toLocaleDateString()}`),(0,e.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Recent Transactions"),...n])}})}return t}catch(t){throw new Error(`Failed to get transaction history: ${t?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(t){try{const{network:n}=t;if(!["mainnet","testnet"].includes(n))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Switch TRON Network"),(0,e.text)(`Switch to TRON ${n}?`),(0,e.divider)(),(0,e.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await i.switchNetwork(n),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${n}`}}),{network:n}}catch(t){throw new Error(`Failed to switch network: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_connect":return await async function(t){try{const{origin:e,name:n,icon:a}=t||{};if(!e||!n)throw new Error("dApp origin and name are required");const r=await c.connectDApp({origin:e,name:n,icon:a});return{connected:!0,session:{accounts:r.accounts,chainId:r.chainId,origin:r.origin,name:r.name}}}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_sessions":return await async function(){try{const t=c.getActiveSessions();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Active dApp Connections"),...0===t.length?[(0,e.text)("No active dApp connections.")]:t.map(t=>[(0,e.text)(`**${t.name}**`),(0,e.text)(`Origin: ${t.origin}`),(0,e.text)(`Connected: ${new Date(t.connectedAt).toLocaleString()}`),(0,e.divider)()]).flat()])}}),{sessions:t}}catch(t){throw new Error(`Failed to get sessions: ${t?.message||"Unknown error"}`)}}();case"tron_dapp_disconnect":return await async function(t){try{const{origin:e,all:n}=t||{};if(n)await c.disconnectAll();else{if(!e)throw new Error("Must specify origin or all=true");await c.disconnectDApp(e)}return{disconnected:!0}}catch(t){throw new Error(`Failed to disconnect: ${t?.message||"Unknown error"}`)}}(n.params);default:throw new Error(`Method ${n.method} not supported`)}}catch(t){throw console.error("RPC request error:",t),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${t?.message||"Unknown error"}`}}),t}}})();var r=exports;for(var s in a)r[s]=a[s];a.__esModule&&Object.defineProperty(r,"__esModule",{value:!0})})();