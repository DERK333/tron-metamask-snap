(()=>{"use strict";var t={116:(t,e)=>{function a(t){return!(!t||"string"!=typeof t)&&/^T[A-Za-z0-9]{33}$/.test(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.validateTronAddress=a,e.formatTrx=function(t){return(("string"==typeof t?parseFloat(t):t)/1e6).toFixed(6)},e.trxToSun=function(t){const e="string"==typeof t?parseFloat(t):t;return Math.floor(1e6*e)},e.truncateAddress=function(t,e=6,a=4){return!t||t.length<=e+a?t:`${t.slice(0,e)}...${t.slice(-a)}`},e.formatTimestamp=function(t){return new Date(t).toLocaleString()},e.validateAmount=function(t){if(!t||"string"!=typeof t)return!1;const e=parseFloat(t);return!isNaN(e)&&e>0&&e<=1e6},e.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},e.parseErrorMessage=function(t){return"string"==typeof t?t:t?.message?t.message:t?.error?t.error:"An unknown error occurred"},e.validateNetwork=function(t){return"mainnet"===t||"testnet"===t},e.formatBalance=function(t,e=6){return t.toFixed(e).replace(/\.?0+$/,"")},e.isValidTronAddress=function(t){return a(t)&&34===t.length},e.sanitizeInput=function(t){return"string"!=typeof t?"":t.trim().replace(/[<>]/g,"")},e.calculateTxFee=function(){return 1},e.checkSufficientBalance=function(t,e){return e>=parseFloat(t)+1}},218:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronService=void 0;const n=a(576);e.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const t=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),e=await(0,n.getBIP44AddressKeyDeriver)(t),a=await e(195),r=this.privateKeyToAddress(a.privateKey||"");return this.account={address:r,privateKey:a.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(t){throw new Error(`Failed to connect: ${t?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!t?.tronAccount)throw new Error("No account found. Please connect first.");this.account=t.tronAccount}return this.account}async getBalance(){const t=await this.getAccount();try{const e=await this.makeRpcCall("wallet/getaccount",{address:t.address,visible:!0});return e?.balance?e.balance/1e6:0}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}async sendTransaction(t,e,a){const n=await this.getAccount();try{const a={to_address:t,owner_address:n.address,amount:Math.floor(1e6*parseFloat(e)),visible:!0},r=await this.makeRpcCall("wallet/createtransaction",a);if(!r?.txID)throw new Error("Failed to create transaction");const s=await this.signTransaction(r,n.privateKey),o=await this.makeRpcCall("wallet/broadcasttransaction",s);if(!o?.result)throw new Error(o?.message||"Transaction broadcast failed");return r.txID}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}async signMessage(t){const e=await this.getAccount();try{const a=Buffer.from(t,"utf8").toString("hex");return await this.signHex(a,e.privateKey)}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}async getTransactionHistory(){const t=await this.getAccount();try{const e=await this.makeRpcCall("v1/accounts/"+t.address+"/transactions",null,"GET");return e?.data?e.data.map(t=>({txId:t.txID||"",type:this.getTransactionType(t.raw_data?.contract?.[0]?.type||""),amount:(t.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:t.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:t.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:t.block_timestamp||0,status:t.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(t){return[]}}async switchNetwork(t){this.network=t,this.account&&(this.account.network=t,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(t,e,a="POST"){const n="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",r={method:a,headers:{"Content-Type":"application/json"}};e&&"POST"===a&&(r.body=JSON.stringify(e));const s=await fetch(`${n}/${t}`,r);if(!s.ok)throw new Error(`RPC call failed: ${s.statusText}`);return await s.json()}privateKeyToAddress(t){return"T"+this.simpleHash(t).slice(0,33)}simpleHash(t){let e=0;for(let a=0;a<t.length;a++)e=(e<<5)-e+t.charCodeAt(a),e&=e;return Math.abs(e).toString(16).padStart(33,"0")}async signTransaction(t,e){const a=await this.signHex(t.txID,e);return{...t,signature:[a]}}async signHex(t,e){return this.simpleHash(t+e)}getTransactionType(t){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract",FreezeBalanceV2Contract:"Stake TRX",UnfreezeBalanceV2Contract:"Unstake TRX",VoteWitnessContract:"Vote for SR",WithdrawExpireUnfreezeContract:"Withdraw Unstaked"}[t]||"Unknown"}async stakeTRX(t,e,a=3){if(!this.account)throw new Error("Not connected");const n=Math.round(1e6*parseFloat(t)),r={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,frozen_balance:n,resource:e,frozen_duration:a},type_url:"type.googleapis.com/protocol.FreezeBalanceV2Contract"},type:"FreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`stake-${this.account.address}-${t}-${Date.now()}`)},s=await this.signTransaction(r,this.account.privateKey),o=await this.makeRpcCall("/wallet/broadcasttransaction",s);return o?.txid||r.txID}async unstakeTRX(t,e){if(!this.account)throw new Error("Not connected");const a=Math.round(1e6*parseFloat(t)),n={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,unfreeze_balance:a,resource:e},type_url:"type.googleapis.com/protocol.UnfreezeBalanceV2Contract"},type:"UnfreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`unstake-${this.account.address}-${t}-${Date.now()}`)},r=await this.signTransaction(n,this.account.privateKey),s=await this.makeRpcCall("/wallet/broadcasttransaction",r);return s?.txid||n.txID}async voteForSR(t){if(!this.account)throw new Error("Not connected");const e={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,votes:t.map(t=>({vote_address:t.address,vote_count:t.count}))},type_url:"type.googleapis.com/protocol.VoteWitnessContract"},type:"VoteWitnessContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`vote-${this.account.address}-${JSON.stringify(t)}-${Date.now()}`)},a=await this.signTransaction(e,this.account.privateKey),n=await this.makeRpcCall("/wallet/broadcasttransaction",a);return n?.txid||e.txID}async getStakingInfo(){if(!this.account)throw new Error("Not connected");try{const t=await this.makeRpcCall("/wallet/getaccountresource",{address:this.account.address},"POST"),e=(await this.makeRpcCall("/wallet/getdelegatedresourceaccountindexv2",{value:this.account.address},"POST"),await this.makeRpcCall("/wallet/getaccount",{address:this.account.address},"POST")),a=t?.frozen_balance_for_energy||0,n=t?.frozen_balance_for_bandwidth||0;return{frozen:(a+n)/1e6,frozenEnergy:a/1e6,frozenBandwidth:n/1e6,votes:e?.votes?.map(t=>({address:t.vote_address,name:`SR ${t.vote_address.substring(0,10)}...`,votes:t.vote_count}))||[],rewards:0,canUnfreezeIn:0}}catch(t){return{frozen:0,frozenEnergy:0,frozenBandwidth:0,votes:[],rewards:0,canUnfreezeIn:0}}}async getSuperRepresentatives(){try{const t=await this.makeRpcCall("/wallet/listwitnesses",{},"POST");return t?.witnesses?t.witnesses.map((t,e)=>({address:t.address,name:t.url||`SR #${e+1}`,url:t.url||"",totalVotes:t.voteCount||0,totalProduced:t.totalProduced||0,ranking:e+1,productivity:t.totalProduced>0?t.totalProduced/(t.totalProduced+t.totalMissed||0)*100:0})).slice(0,27):this.getMockSuperRepresentatives()}catch(t){return this.getMockSuperRepresentatives()}}getMockSuperRepresentatives(){return[{address:"TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH",name:"Binance Staking",url:"https://binance.com",totalVotes:1615e7,totalProduced:15e5,ranking:1,productivity:99.5},{address:"TZ6p83xJA9kFZYRXfkKGgqwrqmFgDvbRds",name:"Poloniex",url:"https://poloniex.com",totalVotes:1452e7,totalProduced:145e4,ranking:2,productivity:99.2},{address:"TEVAq6pqDSNmE8Q8nC9qDQAA6VeF9Kux5Y",name:"TRONScan",url:"https://tronscan.org",totalVotes:128e8,totalProduced:142e4,ranking:3,productivity:99.8}]}async withdrawExpiredUnfrozen(){if(!this.account)throw new Error("Not connected");const t={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address},type_url:"type.googleapis.com/protocol.WithdrawExpireUnfreezeContract"},type:"WithdrawExpireUnfreezeContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`withdraw-${this.account.address}-${Date.now()}`)},e=await this.signTransaction(t,this.account.privateKey),a=await this.makeRpcCall("/wallet/broadcasttransaction",e);return a?.txid||t.txID}}},328:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronDAppConnector=void 0;const n=a(360),r=a(940),s=a(848);e.TronDAppConnector=class{constructor(t){this.activeSessions=new Map,this.globalTronObject=null,this.currentUser=null,this.tronService=t,this.previewService=new s.TransactionPreviewService(t),this.initializeGlobalTronObject(),this.initializeDatabase()}async initializeDatabase(){try{await r.tronDatabase.initialize()}catch(t){console.warn("Database initialization failed, using snap state only:",t)}}initializeGlobalTronObject(){this.globalTronObject={isTronLink:!0,isMetaMaskTron:!0,ready:!0,request:this.handleDAppRequest.bind(this),isConnected:this.isConnected.bind(this),requestAccounts:()=>this.handleDAppRequest({method:"tron_requestAccounts"}),getAccount:()=>this.handleDAppRequest({method:"tron_getAccount"}),signMessage:t=>this.handleDAppRequest({method:"tron_signMessage",params:{message:t}}),signTransaction:t=>this.handleDAppRequest({method:"tron_signTransaction",params:t}),sendTransaction:t=>this.handleDAppRequest({method:"tron_sendTransaction",params:t}),chainId:728126428,networkVersion:"mainnet",on:this.addEventListener.bind(this),removeListener:this.removeEventListener.bind(this),selectedAddress:null,accounts:[]}}async connectDApp(t){try{if(!await this.showConnectionApproval(t))throw new Error("User rejected connection");const e=await this.tronService.getAccount();await this.ensureUserExists(e.address,e.network),await r.tronDatabase.storeDAppSession(this.currentUser.id,t.origin,t.name,t.icon,"mainnet"===e.network?728126428:2494104990);const a={connected:!0,origin:t.origin,name:t.name,icon:t.icon,accounts:[e.address],chainId:"mainnet"===e.network?728126428:2494104990,connectedAt:Date.now()};return this.activeSessions.set(t.origin,a),this.updateGlobalTronObject(e),await this.notifyUser(`Connected to ${t.name} successfully!`),a}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}async ensureUserExists(t,e){this.currentUser||(this.currentUser=await r.tronDatabase.getUser(t),this.currentUser||(this.currentUser=await r.tronDatabase.storeUser(t,e)))}async handleDAppRequest(t){const{method:e,params:a,origin:n}=t;if(n&&!this.activeSessions.has(n))throw new Error("dApp not connected. Please connect first.");switch(e){case"tron_requestAccounts":return await this.requestAccounts();case"tron_getAccount":return await this.getAccount();case"tron_getBalance":return await this.getBalance();case"tron_signMessage":return await this.signMessage(a);case"tron_signTransaction":return await this.signTransaction(a);case"tron_sendTransaction":return await this.sendTransaction(a);case"tron_switchNetwork":return await this.switchNetwork(a);default:throw new Error(`Unsupported method: ${e}`)}}async requestAccounts(){try{return[(await this.tronService.getAccount()).address]}catch(t){throw new Error("Failed to get accounts")}}async getAccount(){return await this.tronService.getAccount()}async getBalance(){return await this.tronService.getBalance()}async signMessage(t){const{message:e}=t;if(!await this.showSigningApproval(e))throw new Error("User rejected message signing");return await this.tronService.signMessage(e)}async signTransaction(t){if(!await this.showTransactionApproval(t,"sign"))throw new Error("User rejected transaction signing");const e=await this.tronService.getAccount();return await this.tronService.signTransaction(t,e.privateKey)}async sendTransaction(t){if(!await this.showTransactionApproval(t,"send"))throw new Error("User rejected transaction");return await this.tronService.sendTransaction(t.to||t.to_address,t.amount||t.value,t.data)}async switchNetwork(t){await this.tronService.switchNetwork(t.network);for(const e of this.activeSessions.values())e.chainId="mainnet"===t.network?728126428:2494104990}isConnected(){return this.activeSessions.size>0}getActiveSessions(){return Array.from(this.activeSessions.values())}async disconnectDApp(t){this.activeSessions.delete(t),await this.notifyUser(`Disconnected from ${t}`)}async disconnectAll(){this.activeSessions.clear(),this.updateGlobalTronObject(null),await this.notifyUser("Disconnected from all dApps")}updateGlobalTronObject(t){this.globalTronObject&&(this.globalTronObject.selectedAddress=t?.address||null,this.globalTronObject.accounts=t?[t.address]:[],this.globalTronObject.chainId="mainnet"===t?.network?728126428:2494104990,this.globalTronObject.networkVersion=t?.network||"mainnet")}async showConnectionApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,n.panel)([(0,n.heading)("dApp Connection Request"),(0,n.text)(`**${t.name}** wants to connect to your TRON wallet.`),(0,n.divider)(),(0,n.text)("**Origin:**"),(0,n.text)(t.origin),(0,n.divider)(),(0,n.text)("This will allow the dApp to:"),(0,n.text)("â€¢ View your TRON address"),(0,n.text)("â€¢ Request transaction signatures"),(0,n.text)("â€¢ Send transaction requests"),(0,n.text)("â€¢ View your balance"),(0,n.divider)(),(0,n.text)("âš ï¸ Only connect to dApps you trust.")])}})}async showSigningApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,n.panel)([(0,n.heading)("Sign Message Request"),(0,n.text)("A dApp is requesting you to sign a message:"),(0,n.divider)(),(0,n.text)("**Message:**"),(0,n.copyable)(t),(0,n.divider)(),(0,n.text)("âš ï¸ Only sign messages you trust and understand.")])}})}async showTransactionApproval(t,e){const a=await this.tronService.getAccount(),r=t.to||t.to_address||"Unknown",s=t.value||t.amount||"0",o=await this.previewService.getNetworkStatus(a.network),i=await this.previewService.analyzeTransactionRisk(r,s,a.address),c=await this.previewService.simulateTransaction(r,s,a.address),d=await this.previewService.getContractDetails(r,t.data),u={from:a.address,to:r,amount:s,memo:t.data,estimatedFee:1,networkStatus:o,riskLevel:i,contractInteraction:d,simulationResult:c},l=await this.previewService.buildTransactionPreview(u),p=[(0,n.heading)(`ðŸ” ${"sign"===e?"Sign":"Send"} Transaction Request`),(0,n.text)(`**dApp:** ${this.activeSessions.get(t.origin)?.name||"Unknown"}`),(0,n.divider)(),...l];return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,n.panel)(p)}})}addEventListener(t,e){console.log(`Event listener added for: ${t}`)}removeEventListener(t,e){console.log(`Event listener removed for: ${t}`)}async notifyUser(t){await snap.request({method:"snap_notify",params:{type:"inApp",message:t}})}}},360:t=>{t.exports=require("@metamask/snaps-ui")},576:t=>{t.exports=require("@metamask/key-tree")},848:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TransactionPreviewService=void 0;const n=a(360),r=a(116);e.TransactionPreviewService=class{constructor(t){this.tronService=t}async buildTransactionPreview(t){const e=[];return e.push((0,n.heading)("ðŸ” Transaction Preview"),(0,n.divider)()),e.push((0,n.text)("**ðŸ“¤ From:**"),(0,n.copyable)(t.from),(0,n.text)("**ðŸ“¥ To:**"),(0,n.copyable)(t.to),(0,n.text)("**ðŸ’° Amount:**"),(0,n.text)(`${t.amount} TRX`),(0,n.divider)()),t.memo&&e.push((0,n.text)("**ðŸ“ Memo:**"),(0,n.text)(t.memo),(0,n.divider)()),t.networkStatus&&e.push(...this.buildNetworkStatus(t.networkStatus)),t.riskLevel&&e.push(...this.buildRiskAssessment(t.riskLevel)),e.push(...this.buildFeeEstimation(t.estimatedFee||(0,r.calculateTxFee)())),t.contractInteraction?.isContract&&e.push(...this.buildContractDetails(t.contractInteraction)),t.simulationResult&&e.push(...this.buildSimulationResults(t.simulationResult)),e.push((0,n.divider)(),(0,n.text)("**ðŸ“Š Transaction Summary:**"),(0,n.text)(`â€¢ Total Cost: ${(parseFloat(t.amount)+(t.estimatedFee||(0,r.calculateTxFee)())).toFixed(6)} TRX`),(0,n.text)(`â€¢ Network: ${t.networkStatus?.networkName||"Unknown"}`),(0,n.text)(`â€¢ Risk Level: ${this.getRiskEmoji(t.riskLevel?.level)} ${t.riskLevel?.level||"Unknown"}`)),e}buildNetworkStatus(t){return[(0,n.text)("**ðŸŒ Network Status:**"),(0,n.text)(`â€¢ Congestion: ${{low:"ðŸŸ¢",medium:"ðŸŸ¡",high:"ðŸ”´"}[t.congestion]} ${t.congestion}`),(0,n.text)(`â€¢ Block Height: ${t.currentBlock.toLocaleString()}`),(0,n.text)(`â€¢ Avg Block Time: ${t.averageBlockTime}s`),(0,n.divider)()]}buildRiskAssessment(t){const e=[(0,n.text)(`**âš ï¸ Risk Assessment: ${this.getRiskEmoji(t.level)} ${t.level.toUpperCase()}**`),(0,n.text)(`Risk Score: ${t.score}/100`)];return t.warnings.length>0&&(e.push((0,n.text)("**Warnings:**")),t.warnings.forEach(t=>{e.push((0,n.text)(`â€¢ ${t}`))})),e.push((0,n.divider)()),e}buildFeeEstimation(t){return[(0,n.text)("**â›½ Fee Estimation:**"),(0,n.text)(`â€¢ Base Fee: ${t} TRX`),(0,n.text)("â€¢ Energy: Included"),(0,n.text)("â€¢ Bandwidth: Included"),(0,n.divider)()]}buildContractDetails(t){return[(0,n.text)("**ðŸ“„ Smart Contract Interaction:**"),(0,n.text)(`â€¢ Type: ${t.contractType||"Unknown"}`),(0,n.text)(`â€¢ Method: ${t.method||"Unknown"}`),(0,n.divider)()]}buildSimulationResults(t){const e=[(0,n.text)("**ðŸ§ª Simulation Results:**"),(0,n.text)("â€¢ Status: "+(t.success?"âœ… Success":"âŒ Failed"))];return t.success?(void 0!==t.energyUsed&&e.push((0,n.text)(`â€¢ Energy Used: ${t.energyUsed.toLocaleString()}`)),void 0!==t.bandwidthUsed&&e.push((0,n.text)(`â€¢ Bandwidth Used: ${t.bandwidthUsed.toLocaleString()}`))):t.error&&e.push((0,n.text)(`â€¢ Error: ${t.error}`)),e.push((0,n.divider)()),e}getRiskEmoji(t){switch(t){case"low":return"ðŸŸ¢";case"medium":return"ðŸŸ¡";case"high":return"ðŸ”´";default:return"âšª"}}async analyzeTransactionRisk(t,e,a){const n=[];let s=0;(0,r.validateTronAddress)(t)||(n.push("Invalid recipient address format"),s+=50),await this.isNewAddress(t)&&(n.push("First transaction to this address"),s+=20);const o=await this.tronService.getBalance(),i=parseFloat(e)/parseFloat((0,r.formatTrx)(o))*100;let c;return i>50&&(n.push(`Sending ${i.toFixed(0)}% of your balance`),s+=30),await this.isContractAddress(t)&&(n.push("Recipient is a smart contract"),s+=15),c=s>=60?"high":s>=30?"medium":"low",{level:c,warnings:n,score:s}}async getNetworkStatus(t){try{return{congestion:"low",averageBlockTime:3,currentBlock:12345678,networkName:"mainnet"===t?"TRON Mainnet":"TRON Testnet (Shasta)"}}catch(e){return{congestion:"medium",averageBlockTime:3,currentBlock:0,networkName:t}}}async simulateTransaction(t,e,a){try{const a=(0,r.validateTronAddress)(t),n=await this.checkSufficientBalance(e);return a?n?{success:!0,energyUsed:5e3,bandwidthUsed:200}:{success:!1,error:"Insufficient balance"}:{success:!1,error:"Invalid recipient address"}}catch(t){return{success:!1,error:t.message||"Simulation failed"}}}async isNewAddress(t){return!1}async isContractAddress(t){return t.startsWith("TR")||t.startsWith("TE")}async checkSufficientBalance(t){const e=await this.tronService.getBalance(),a=parseFloat(t)+(0,r.calculateTxFee)();return parseFloat((0,r.formatTrx)(e))>=a}async getContractDetails(t,e){return await this.isContractAddress(t)?{isContract:!0,contractType:"TRC20",method:"transfer",params:e}:{isContract:!1}}}},940:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tronDatabase=e.TronDatabaseService=void 0;class a{static getInstance(){return a.instance||(a.instance=new a),a.instance}constructor(){this.isInitialized=!1}async initialize(){if(!this.isInitialized)try{await this.testConnection(),this.isInitialized=!0}catch(t){console.warn("Database not available, using snap state storage only:",t),this.isInitialized=!1}}async testConnection(){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL not available")}async storeUser(t,e){const a={id:Date.now(),address:t,network:e,createdAt:(new Date).toISOString()};try{return this.isInitialized,await this.storeInSnapState("user",a),a}catch(t){throw console.error("Failed to store user:",t),t}}async getUser(t){try{return this.isInitialized,await this.getFromSnapState("user")}catch(t){return console.error("Failed to get user:",t),null}}async storeDAppSession(t,e,a,n,r){const s={id:Date.now(),userId:t,origin:e,name:a,icon:n,chainId:r,isActive:!0,connectedAt:(new Date).toISOString(),lastAccessAt:(new Date).toISOString()};try{const a=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);return a.push(s),await this.storeInSnapState("dappSessions",a),s}catch(t){throw console.error("Failed to store dApp session:",t),t}}async getDAppSessions(t){try{return(await this.getFromSnapState("dappSessions")||[]).filter(e=>e.userId===t)}catch(t){return console.error("Failed to get dApp sessions:",t),[]}}async getActiveDAppSessions(t){return(await this.getDAppSessions(t)).filter(t=>t.isActive)}async deactivateDAppSession(t,e){try{const a=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);await this.storeInSnapState("dappSessions",a)}catch(t){console.error("Failed to deactivate dApp session:",t)}}async deactivateAllDAppSessions(t){try{const e=(await this.getDAppSessions(t)).map(t=>({...t,isActive:!1}));await this.storeInSnapState("dappSessions",e)}catch(t){console.error("Failed to deactivate all dApp sessions:",t)}}async storeTransaction(t,e,a,n,r,s,o,i,c){const d={id:Date.now(),userId:t,sessionId:e,txId:a,type:n,amount:r,toAddress:s,fromAddress:o,status:"pending",network:i,metadata:c,createdAt:(new Date).toISOString()};try{const e=await this.getTransactions(t);return e.unshift(d),e.length>100&&e.splice(100),await this.storeInSnapState("transactions",e),d}catch(t){throw console.error("Failed to store transaction:",t),t}}async getTransactions(t,e=50){try{return(await this.getFromSnapState("transactions")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get transactions:",t),[]}}async updateTransactionStatus(t,e){try{const a=(await this.getFromSnapState("transactions")||[]).map(a=>a.txId===t?{...a,status:e,confirmedAt:"confirmed"===e?(new Date).toISOString():a.confirmedAt}:a);await this.storeInSnapState("transactions",a)}catch(t){console.error("Failed to update transaction status:",t)}}async storeSignedMessage(t,e,a,n,r){const s={id:Date.now(),userId:t,sessionId:e,message:a,signature:n,messageHash:r,createdAt:(new Date).toISOString()};try{const e=await this.getSignedMessages(t);return e.unshift(s),e.length>50&&e.splice(50),await this.storeInSnapState("signedMessages",e),s}catch(t){throw console.error("Failed to store signed message:",t),t}}async getSignedMessages(t,e=25){try{return(await this.getFromSnapState("signedMessages")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get signed messages:",t),[]}}async storeInSnapState(t,e){const a=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...a,[t]:e}}})}async getFromSnapState(t){const e=await snap.request({method:"snap_manageState",params:{operation:"get"}});return e?.[t]}}e.TronDatabaseService=a,a.instance=null,e.tronDatabase=a.getInstance()}},e={};function a(n){var r=e[n];if(void 0!==r)return r.exports;var s=e[n]={exports:{}};return t[n](s,s.exports,a),s.exports}var n={};(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.onRpcRequest=void 0;const e=a(360),r=a(218),s=a(328),o=a(116),i=a(848),c=new r.TronService,d=new i.TransactionPreviewService(c),u=new s.TronDAppConnector(c);t.onRpcRequest=async({origin:t,request:a})=>{try{switch(a.method){case"tron_connect":return await async function(){try{const t=await c.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Connect to TRON Network"),(0,e.text)("This will create a TRON account derived from your MetaMask seed phrase."),(0,e.divider)(),(0,e.text)("**Account Address:**"),(0,e.copyable)(t.address),(0,e.text)("**Network:**"),(0,e.text)(t.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully connected to TRON network!"}}),t;throw new Error("User rejected connection")}catch(t){throw new Error(`Failed to connect to TRON: ${t?.message||"Unknown error"}`)}}();case"tron_getAccount":return await async function(){try{return await c.getAccount()}catch(t){throw new Error(`Failed to get account: ${t?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const t=await c.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("TRON Balance"),(0,e.text)(`**Balance:** ${(0,o.formatTrx)(t)} TRX`)])}}),{balance:(0,o.formatTrx)(t),unit:"TRX"}}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(t){try{const{to:a,amount:n,memo:r}=t;if(!(0,o.validateTronAddress)(a))throw new Error("Invalid TRON address");if(!n||parseFloat(n)<=0)throw new Error("Invalid amount");const s=await c.getAccount(),i=await c.getBalance();if(parseFloat(n)>parseFloat((0,o.formatTrx)(i)))throw new Error("Insufficient balance");const u=await d.getNetworkStatus(s.network),l=await d.analyzeTransactionRisk(a,n,s.address),p=await d.simulateTransaction(a,n,s.address),w=await d.getContractDetails(a),h={from:s.address,to:a,amount:n,memo:r,estimatedFee:1,networkStatus:u,riskLevel:l,contractInteraction:w,simulationResult:p},g=await d.buildTransactionPreview(h);if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)(g)}}))throw new Error("Transaction cancelled by user");const m=await c.sendTransaction(a,n,r);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${m}`}}),{txHash:m,status:"pending"}}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_signMessage":return await async function(t){try{const{message:a}=t;if(!a)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Sign Message"),(0,e.text)("**Message to sign:**"),(0,e.text)(a),(0,e.divider)(),(0,e.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await c.signMessage(a)}}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_getTransactionHistory":return await async function(){try{const t=await c.getTransactionHistory();if(0===t.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Transaction History"),(0,e.text)("No transactions found.")])}});else{const a=t.slice(0,5).map(t=>[(0,e.text)(`**${t.type}** - ${(0,o.formatTrx)(t.amount)} TRX`),(0,e.text)(`To: ${t.to}`),(0,e.text)(`${new Date(t.timestamp).toLocaleDateString()}`),(0,e.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Recent Transactions"),...a])}})}return t}catch(t){throw new Error(`Failed to get transaction history: ${t?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(t){try{const{network:a}=t;if(!["mainnet","testnet"].includes(a))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Switch TRON Network"),(0,e.text)(`Switch to TRON ${a}?`),(0,e.divider)(),(0,e.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await c.switchNetwork(a),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${a}`}}),{network:a}}catch(t){throw new Error(`Failed to switch network: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_dapp_connect":return await async function(t){try{const{origin:e,name:a,icon:n}=t||{};if(!e||!a)throw new Error("dApp origin and name are required");const r=await u.connectDApp({origin:e,name:a,icon:n});return{connected:!0,session:{accounts:r.accounts,chainId:r.chainId,origin:r.origin,name:r.name}}}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_dapp_sessions":return await async function(){try{const t=u.getActiveSessions();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Active dApp Connections"),...0===t.length?[(0,e.text)("No active dApp connections.")]:t.map(t=>[(0,e.text)(`**${t.name}**`),(0,e.text)(`Origin: ${t.origin}`),(0,e.text)(`Connected: ${new Date(t.connectedAt).toLocaleString()}`),(0,e.divider)()]).flat()])}}),{sessions:t}}catch(t){throw new Error(`Failed to get sessions: ${t?.message||"Unknown error"}`)}}();case"tron_dapp_disconnect":return await async function(t){try{const{origin:e,all:a}=t||{};if(a)await u.disconnectAll();else{if(!e)throw new Error("Must specify origin or all=true");await u.disconnectDApp(e)}return{disconnected:!0}}catch(t){throw new Error(`Failed to disconnect: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_stake":return await async function(t){try{const{amount:a,resource:n="ENERGY"}=t;if(!a||parseFloat(a)<=0)throw new Error("Invalid staking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Stake TRX"),(0,e.text)(`You are about to stake **${(0,o.formatTrx)(a)} TRX** for **${n}**.`),(0,e.divider)(),(0,e.text)("**Staking Details:**"),(0,e.text)(`â€¢ Resource: ${n}`),(0,e.text)("â€¢ Lock Period: 3 days"),(0,e.text)("â€¢ You can unstake anytime, but need to wait 14 days to withdraw"),(0,e.divider)(),(0,e.text)("**Benefits:**"),(0,e.text)("â€¢ Earn voting rights (1 TRX = 1 vote)"),(0,e.text)(`â€¢ Get free ${n.toLowerCase()} for transactions`),(0,e.text)("â€¢ Support the TRON network")])}}))throw new Error("Staking cancelled by user");const r=await c.stakeTRX(a,n);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully staked ${(0,o.formatTrx)(a)} TRX for ${n}`}}),{txHash:r,amount:a,resource:n}}catch(t){throw new Error(`Staking failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_unstake":return await async function(t){try{const{amount:a,resource:n="ENERGY"}=t;if(!a||parseFloat(a)<=0)throw new Error("Invalid unstaking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Unstake TRX"),(0,e.text)(`You are about to unstake **${(0,o.formatTrx)(a)} TRX** from **${n}**.`),(0,e.divider)(),(0,e.text)("**Important:**"),(0,e.text)("â€¢ Unstaked TRX will be locked for 14 days"),(0,e.text)("â€¢ You will lose voting rights for this amount"),(0,e.text)(`â€¢ Free ${n.toLowerCase()} will be reduced`),(0,e.divider)(),(0,e.text)("Are you sure you want to continue?")])}}))throw new Error("Unstaking cancelled by user");const r=await c.unstakeTRX(a,n);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully unstaked ${(0,o.formatTrx)(a)} TRX. Available for withdrawal in 14 days.`}}),{txHash:r,amount:a,resource:n}}catch(t){throw new Error(`Unstaking failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_vote":return await async function(t){try{const{votes:a}=t;if(!a||!Array.isArray(a)||0===a.length)throw new Error("Invalid votes parameter");const n=a.reduce((t,e)=>t+(e.count||0),0),r=await c.getStakingInfo(),s=Math.floor(r.frozen);if(n>s)throw new Error(`Insufficient voting power. You have ${s} votes available.`);const o=a.map(t=>[(0,e.text)(`â€¢ ${t.name||t.address.substring(0,10)+"..."}: **${t.count} votes**`)]).flat();if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Vote for Super Representatives"),(0,e.text)(`Total Votes: **${n}** / ${s} available`),(0,e.divider)(),(0,e.text)("**Your Votes:**"),...o,(0,e.divider)(),(0,e.text)("**Note:**"),(0,e.text)("â€¢ Votes are updated every 6 hours"),(0,e.text)("â€¢ You can change votes anytime"),(0,e.text)("â€¢ Voting helps secure the network")])}}))throw new Error("Voting cancelled by user");const i=await c.voteForSR(a);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully voted for ${a.length} Super Representative(s)`}}),{txHash:i,votes:a.length,totalVotes:n}}catch(t){throw new Error(`Voting failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_getStakingInfo":return await async function(){try{const t=await c.getStakingInfo(),a=t.votes.length>0?t.votes.map(t=>(0,e.text)(`â€¢ ${t.name}: ${t.votes} votes`)):[(0,e.text)("No active votes")];return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Staking Information"),(0,e.divider)(),(0,e.text)("**Staked Balance:**"),(0,e.text)(`â€¢ Total: ${(0,o.formatTrx)(t.frozen.toString())} TRX`),(0,e.text)(`â€¢ For Energy: ${(0,o.formatTrx)(t.frozenEnergy.toString())} TRX`),(0,e.text)(`â€¢ For Bandwidth: ${(0,o.formatTrx)(t.frozenBandwidth.toString())} TRX`),(0,e.divider)(),(0,e.text)("**Voting Power:**"),(0,e.text)(`â€¢ Available: ${Math.floor(t.frozen)} votes`),(0,e.divider)(),(0,e.text)("**Active Votes:**"),...a,(0,e.divider)(),(0,e.text)(`**Rewards:** ${(0,o.formatTrx)(t.rewards.toString())} TRX`)])}}),t}catch(t){throw new Error(`Failed to get staking info: ${t?.message||"Unknown error"}`)}}();case"tron_getSuperRepresentatives":return await async function(){try{const t=await c.getSuperRepresentatives(),a=t.slice(0,5).map(t=>[(0,e.text)(`**#${t.ranking} ${t.name}**`),(0,e.text)(`Votes: ${(t.totalVotes/1e6).toFixed(2)}M`),(0,e.text)(`Productivity: ${t.productivity.toFixed(1)}%`),(0,e.divider)()]).flat();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Top Super Representatives"),(0,e.text)("Vote for SRs to earn rewards and support the network"),(0,e.divider)(),...a,(0,e.text)("... and more")])}}),t}catch(t){throw new Error(`Failed to get Super Representatives: ${t?.message||"Unknown error"}`)}}();case"tron_withdrawExpiredUnfrozen":return await async function(){try{if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Withdraw Unfrozen Balance"),(0,e.text)("Withdraw any TRX that has completed the 14-day unstaking period."),(0,e.divider)(),(0,e.text)("This will transfer all available unfrozen TRX back to your account.")])}}))throw new Error("Withdrawal cancelled by user");const t=await c.withdrawExpiredUnfrozen();return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully withdrew unfrozen balance"}}),{txHash:t}}catch(t){throw new Error(`Withdrawal failed: ${t?.message||"Unknown error"}`)}}();default:throw new Error(`Method ${a.method} not supported`)}}catch(t){throw console.error("RPC request error:",t),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${t?.message||"Unknown error"}`}}),t}}})();var r=exports;for(var s in n)r[s]=n[s];n.__esModule&&Object.defineProperty(r,"__esModule",{value:!0})})();