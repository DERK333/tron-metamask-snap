(()=>{"use strict";var t={116:(t,e)=>{function n(t){return!(!t||"string"!=typeof t)&&/^T[A-Za-z0-9]{33}$/.test(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.validateTronAddress=n,e.formatTrx=function(t){return(("string"==typeof t?parseFloat(t):t)/1e6).toFixed(6)},e.trxToSun=function(t){const e="string"==typeof t?parseFloat(t):t;return Math.floor(1e6*e)},e.truncateAddress=function(t,e=6,n=4){return!t||t.length<=e+n?t:`${t.slice(0,e)}...${t.slice(-n)}`},e.formatTimestamp=function(t){return new Date(t).toLocaleString()},e.validateAmount=function(t){if(!t||"string"!=typeof t)return!1;const e=parseFloat(t);return!isNaN(e)&&e>0&&e<=1e6},e.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},e.parseErrorMessage=function(t){return"string"==typeof t?t:t?.message?t.message:t?.error?t.error:"An unknown error occurred"},e.validateNetwork=function(t){return"mainnet"===t||"testnet"===t},e.formatBalance=function(t,e=6){return t.toFixed(e).replace(/\.?0+$/,"")},e.isValidTronAddress=function(t){return n(t)&&34===t.length},e.sanitizeInput=function(t){return"string"!=typeof t?"":t.trim().replace(/[<>]/g,"")},e.calculateTxFee=function(){return 1},e.checkSufficientBalance=function(t,e){return e>=parseFloat(t)+1}},218:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronService=void 0;const a=n(576);e.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const t=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),e=await(0,a.getBIP44AddressKeyDeriver)(t),n=await e(195),s=this.privateKeyToAddress(n.privateKey||"");return this.account={address:s,privateKey:n.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(t){throw new Error(`Failed to connect: ${t?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!t?.tronAccount)throw new Error("No account found. Please connect first.");this.account=t.tronAccount}return this.account}async getBalance(){const t=await this.getAccount();try{const e=await this.makeRpcCall("wallet/getaccount",{address:t.address,visible:!0});return e?.balance?e.balance/1e6:0}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}async sendTransaction(t,e,n){const a=await this.getAccount();try{const n={to_address:t,owner_address:a.address,amount:Math.floor(1e6*parseFloat(e)),visible:!0},s=await this.makeRpcCall("wallet/createtransaction",n);if(!s?.txID)throw new Error("Failed to create transaction");const r=await this.signTransaction(s,a.privateKey),i=await this.makeRpcCall("wallet/broadcasttransaction",r);if(!i?.result)throw new Error(i?.message||"Transaction broadcast failed");return s.txID}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}async signMessage(t){const e=await this.getAccount();try{const n=Buffer.from(t,"utf8").toString("hex");return await this.signHex(n,e.privateKey)}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}async getTransactionHistory(){const t=await this.getAccount();try{const e=await this.makeRpcCall("v1/accounts/"+t.address+"/transactions",null,"GET");return e?.data?e.data.map(t=>({txId:t.txID||"",type:this.getTransactionType(t.raw_data?.contract?.[0]?.type||""),amount:(t.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:t.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:t.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:t.block_timestamp||0,status:t.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(t){return[]}}async switchNetwork(t){this.network=t,this.account&&(this.account.network=t,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(t,e,n="POST"){const a="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",s={method:n,headers:{"Content-Type":"application/json"}};e&&"POST"===n&&(s.body=JSON.stringify(e));const r=await fetch(`${a}/${t}`,s);if(!r.ok)throw new Error(`RPC call failed: ${r.statusText}`);return await r.json()}privateKeyToAddress(t){return"T"+this.simpleHash(t).slice(0,33)}simpleHash(t){let e=0;for(let n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e&=e;return Math.abs(e).toString(16).padStart(33,"0")}async signTransaction(t,e){const n=await this.signHex(t.txID,e);return{...t,signature:[n]}}async signHex(t,e){return this.simpleHash(t+e)}getTransactionType(t){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract"}[t]||"Unknown"}}},328:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronDAppConnector=void 0;const a=n(360),s=n(940),r=n(848);e.TronDAppConnector=class{constructor(t){this.activeSessions=new Map,this.globalTronObject=null,this.currentUser=null,this.tronService=t,this.previewService=new r.TransactionPreviewService(t),this.initializeGlobalTronObject(),this.initializeDatabase()}async initializeDatabase(){try{await s.tronDatabase.initialize()}catch(t){console.warn("Database initialization failed, using snap state only:",t)}}initializeGlobalTronObject(){this.globalTronObject={isTronLink:!0,isMetaMaskTron:!0,ready:!0,request:this.handleDAppRequest.bind(this),isConnected:this.isConnected.bind(this),requestAccounts:()=>this.handleDAppRequest({method:"tron_requestAccounts"}),getAccount:()=>this.handleDAppRequest({method:"tron_getAccount"}),signMessage:t=>this.handleDAppRequest({method:"tron_signMessage",params:{message:t}}),signTransaction:t=>this.handleDAppRequest({method:"tron_signTransaction",params:t}),sendTransaction:t=>this.handleDAppRequest({method:"tron_sendTransaction",params:t}),chainId:728126428,networkVersion:"mainnet",on:this.addEventListener.bind(this),removeListener:this.removeEventListener.bind(this),selectedAddress:null,accounts:[]}}async connectDApp(t){try{if(!await this.showConnectionApproval(t))throw new Error("User rejected connection");const e=await this.tronService.getAccount();await this.ensureUserExists(e.address,e.network),await s.tronDatabase.storeDAppSession(this.currentUser.id,t.origin,t.name,t.icon,"mainnet"===e.network?728126428:2494104990);const n={connected:!0,origin:t.origin,name:t.name,icon:t.icon,accounts:[e.address],chainId:"mainnet"===e.network?728126428:2494104990,connectedAt:Date.now()};return this.activeSessions.set(t.origin,n),this.updateGlobalTronObject(e),await this.notifyUser(`Connected to ${t.name} successfully!`),n}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}async ensureUserExists(t,e){this.currentUser||(this.currentUser=await s.tronDatabase.getUser(t),this.currentUser||(this.currentUser=await s.tronDatabase.storeUser(t,e)))}async handleDAppRequest(t){const{method:e,params:n,origin:a}=t;if(a&&!this.activeSessions.has(a))throw new Error("dApp not connected. Please connect first.");switch(e){case"tron_requestAccounts":return await this.requestAccounts();case"tron_getAccount":return await this.getAccount();case"tron_getBalance":return await this.getBalance();case"tron_signMessage":return await this.signMessage(n);case"tron_signTransaction":return await this.signTransaction(n);case"tron_sendTransaction":return await this.sendTransaction(n);case"tron_switchNetwork":return await this.switchNetwork(n);default:throw new Error(`Unsupported method: ${e}`)}}async requestAccounts(){try{return[(await this.tronService.getAccount()).address]}catch(t){throw new Error("Failed to get accounts")}}async getAccount(){return await this.tronService.getAccount()}async getBalance(){return await this.tronService.getBalance()}async signMessage(t){const{message:e}=t;if(!await this.showSigningApproval(e))throw new Error("User rejected message signing");return await this.tronService.signMessage(e)}async signTransaction(t){if(!await this.showTransactionApproval(t,"sign"))throw new Error("User rejected transaction signing");const e=await this.tronService.getAccount();return await this.tronService.signTransaction(t,e.privateKey)}async sendTransaction(t){if(!await this.showTransactionApproval(t,"send"))throw new Error("User rejected transaction");return await this.tronService.sendTransaction(t.to||t.to_address,t.amount||t.value,t.data)}async switchNetwork(t){await this.tronService.switchNetwork(t.network);for(const e of this.activeSessions.values())e.chainId="mainnet"===t.network?728126428:2494104990}isConnected(){return this.activeSessions.size>0}getActiveSessions(){return Array.from(this.activeSessions.values())}async disconnectDApp(t){this.activeSessions.delete(t),await this.notifyUser(`Disconnected from ${t}`)}async disconnectAll(){this.activeSessions.clear(),this.updateGlobalTronObject(null),await this.notifyUser("Disconnected from all dApps")}updateGlobalTronObject(t){this.globalTronObject&&(this.globalTronObject.selectedAddress=t?.address||null,this.globalTronObject.accounts=t?[t.address]:[],this.globalTronObject.chainId="mainnet"===t?.network?728126428:2494104990,this.globalTronObject.networkVersion=t?.network||"mainnet")}async showConnectionApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("dApp Connection Request"),(0,a.text)(`**${t.name}** wants to connect to your TRON wallet.`),(0,a.divider)(),(0,a.text)("**Origin:**"),(0,a.text)(t.origin),(0,a.divider)(),(0,a.text)("This will allow the dApp to:"),(0,a.text)("• View your TRON address"),(0,a.text)("• Request transaction signatures"),(0,a.text)("• Send transaction requests"),(0,a.text)("• View your balance"),(0,a.divider)(),(0,a.text)("⚠️ Only connect to dApps you trust.")])}})}async showSigningApproval(t){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("Sign Message Request"),(0,a.text)("A dApp is requesting you to sign a message:"),(0,a.divider)(),(0,a.text)("**Message:**"),(0,a.copyable)(t),(0,a.divider)(),(0,a.text)("⚠️ Only sign messages you trust and understand.")])}})}async showTransactionApproval(t,e){const n=await this.tronService.getAccount(),s=t.to||t.to_address||"Unknown",r=t.value||t.amount||"0",i=await this.previewService.getNetworkStatus(n.network),o=await this.previewService.analyzeTransactionRisk(s,r,n.address),c=await this.previewService.simulateTransaction(s,r,n.address),d=await this.previewService.getContractDetails(s,t.data),u={from:n.address,to:s,amount:r,memo:t.data,estimatedFee:1,networkStatus:i,riskLevel:o,contractInteraction:d,simulationResult:c},l=await this.previewService.buildTransactionPreview(u),p=[(0,a.heading)(`🔐 ${"sign"===e?"Sign":"Send"} Transaction Request`),(0,a.text)(`**dApp:** ${this.activeSessions.get(t.origin)?.name||"Unknown"}`),(0,a.divider)(),...l];return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)(p)}})}addEventListener(t,e){console.log(`Event listener added for: ${t}`)}removeEventListener(t,e){console.log(`Event listener removed for: ${t}`)}async notifyUser(t){await snap.request({method:"snap_notify",params:{type:"inApp",message:t}})}}},360:t=>{t.exports=require("@metamask/snaps-ui")},576:t=>{t.exports=require("@metamask/key-tree")},848:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TransactionPreviewService=void 0;const a=n(360),s=n(116);e.TransactionPreviewService=class{constructor(t){this.tronService=t}async buildTransactionPreview(t){const e=[];return e.push((0,a.heading)("🔍 Transaction Preview"),(0,a.divider)()),e.push((0,a.text)("**📤 From:**"),(0,a.copyable)(t.from),(0,a.text)("**📥 To:**"),(0,a.copyable)(t.to),(0,a.text)("**💰 Amount:**"),(0,a.text)(`${t.amount} TRX`),(0,a.divider)()),t.memo&&e.push((0,a.text)("**📝 Memo:**"),(0,a.text)(t.memo),(0,a.divider)()),t.networkStatus&&e.push(...this.buildNetworkStatus(t.networkStatus)),t.riskLevel&&e.push(...this.buildRiskAssessment(t.riskLevel)),e.push(...this.buildFeeEstimation(t.estimatedFee||(0,s.calculateTxFee)())),t.contractInteraction?.isContract&&e.push(...this.buildContractDetails(t.contractInteraction)),t.simulationResult&&e.push(...this.buildSimulationResults(t.simulationResult)),e.push((0,a.divider)(),(0,a.text)("**📊 Transaction Summary:**"),(0,a.text)(`• Total Cost: ${(parseFloat(t.amount)+(t.estimatedFee||(0,s.calculateTxFee)())).toFixed(6)} TRX`),(0,a.text)(`• Network: ${t.networkStatus?.networkName||"Unknown"}`),(0,a.text)(`• Risk Level: ${this.getRiskEmoji(t.riskLevel?.level)} ${t.riskLevel?.level||"Unknown"}`)),e}buildNetworkStatus(t){return[(0,a.text)("**🌐 Network Status:**"),(0,a.text)(`• Congestion: ${{low:"🟢",medium:"🟡",high:"🔴"}[t.congestion]} ${t.congestion}`),(0,a.text)(`• Block Height: ${t.currentBlock.toLocaleString()}`),(0,a.text)(`• Avg Block Time: ${t.averageBlockTime}s`),(0,a.divider)()]}buildRiskAssessment(t){const e=[(0,a.text)(`**⚠️ Risk Assessment: ${this.getRiskEmoji(t.level)} ${t.level.toUpperCase()}**`),(0,a.text)(`Risk Score: ${t.score}/100`)];return t.warnings.length>0&&(e.push((0,a.text)("**Warnings:**")),t.warnings.forEach(t=>{e.push((0,a.text)(`• ${t}`))})),e.push((0,a.divider)()),e}buildFeeEstimation(t){return[(0,a.text)("**⛽ Fee Estimation:**"),(0,a.text)(`• Base Fee: ${t} TRX`),(0,a.text)("• Energy: Included"),(0,a.text)("• Bandwidth: Included"),(0,a.divider)()]}buildContractDetails(t){return[(0,a.text)("**📄 Smart Contract Interaction:**"),(0,a.text)(`• Type: ${t.contractType||"Unknown"}`),(0,a.text)(`• Method: ${t.method||"Unknown"}`),(0,a.divider)()]}buildSimulationResults(t){const e=[(0,a.text)("**🧪 Simulation Results:**"),(0,a.text)("• Status: "+(t.success?"✅ Success":"❌ Failed"))];return t.success?(void 0!==t.energyUsed&&e.push((0,a.text)(`• Energy Used: ${t.energyUsed.toLocaleString()}`)),void 0!==t.bandwidthUsed&&e.push((0,a.text)(`• Bandwidth Used: ${t.bandwidthUsed.toLocaleString()}`))):t.error&&e.push((0,a.text)(`• Error: ${t.error}`)),e.push((0,a.divider)()),e}getRiskEmoji(t){switch(t){case"low":return"🟢";case"medium":return"🟡";case"high":return"🔴";default:return"⚪"}}async analyzeTransactionRisk(t,e,n){const a=[];let r=0;(0,s.validateTronAddress)(t)||(a.push("Invalid recipient address format"),r+=50),await this.isNewAddress(t)&&(a.push("First transaction to this address"),r+=20);const i=await this.tronService.getBalance(),o=parseFloat(e)/parseFloat((0,s.formatTrx)(i))*100;let c;return o>50&&(a.push(`Sending ${o.toFixed(0)}% of your balance`),r+=30),await this.isContractAddress(t)&&(a.push("Recipient is a smart contract"),r+=15),c=r>=60?"high":r>=30?"medium":"low",{level:c,warnings:a,score:r}}async getNetworkStatus(t){try{return{congestion:"low",averageBlockTime:3,currentBlock:12345678,networkName:"mainnet"===t?"TRON Mainnet":"TRON Testnet (Shasta)"}}catch(e){return{congestion:"medium",averageBlockTime:3,currentBlock:0,networkName:t}}}async simulateTransaction(t,e,n){try{const n=(0,s.validateTronAddress)(t),a=await this.checkSufficientBalance(e);return n?a?{success:!0,energyUsed:5e3,bandwidthUsed:200}:{success:!1,error:"Insufficient balance"}:{success:!1,error:"Invalid recipient address"}}catch(t){return{success:!1,error:t.message||"Simulation failed"}}}async isNewAddress(t){return!1}async isContractAddress(t){return t.startsWith("TR")||t.startsWith("TE")}async checkSufficientBalance(t){const e=await this.tronService.getBalance(),n=parseFloat(t)+(0,s.calculateTxFee)();return parseFloat((0,s.formatTrx)(e))>=n}async getContractDetails(t,e){return await this.isContractAddress(t)?{isContract:!0,contractType:"TRC20",method:"transfer",params:e}:{isContract:!1}}}},940:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tronDatabase=e.TronDatabaseService=void 0;class n{static getInstance(){return n.instance||(n.instance=new n),n.instance}constructor(){this.isInitialized=!1}async initialize(){if(!this.isInitialized)try{await this.testConnection(),this.isInitialized=!0}catch(t){console.warn("Database not available, using snap state storage only:",t),this.isInitialized=!1}}async testConnection(){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL not available")}async storeUser(t,e){const n={id:Date.now(),address:t,network:e,createdAt:(new Date).toISOString()};try{return this.isInitialized,await this.storeInSnapState("user",n),n}catch(t){throw console.error("Failed to store user:",t),t}}async getUser(t){try{return this.isInitialized,await this.getFromSnapState("user")}catch(t){return console.error("Failed to get user:",t),null}}async storeDAppSession(t,e,n,a,s){const r={id:Date.now(),userId:t,origin:e,name:n,icon:a,chainId:s,isActive:!0,connectedAt:(new Date).toISOString(),lastAccessAt:(new Date).toISOString()};try{const n=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);return n.push(r),await this.storeInSnapState("dappSessions",n),r}catch(t){throw console.error("Failed to store dApp session:",t),t}}async getDAppSessions(t){try{return(await this.getFromSnapState("dappSessions")||[]).filter(e=>e.userId===t)}catch(t){return console.error("Failed to get dApp sessions:",t),[]}}async getActiveDAppSessions(t){return(await this.getDAppSessions(t)).filter(t=>t.isActive)}async deactivateDAppSession(t,e){try{const n=(await this.getDAppSessions(t)).map(t=>t.origin===e?{...t,isActive:!1}:t);await this.storeInSnapState("dappSessions",n)}catch(t){console.error("Failed to deactivate dApp session:",t)}}async deactivateAllDAppSessions(t){try{const e=(await this.getDAppSessions(t)).map(t=>({...t,isActive:!1}));await this.storeInSnapState("dappSessions",e)}catch(t){console.error("Failed to deactivate all dApp sessions:",t)}}async storeTransaction(t,e,n,a,s,r,i,o,c){const d={id:Date.now(),userId:t,sessionId:e,txId:n,type:a,amount:s,toAddress:r,fromAddress:i,status:"pending",network:o,metadata:c,createdAt:(new Date).toISOString()};try{const e=await this.getTransactions(t);return e.unshift(d),e.length>100&&e.splice(100),await this.storeInSnapState("transactions",e),d}catch(t){throw console.error("Failed to store transaction:",t),t}}async getTransactions(t,e=50){try{return(await this.getFromSnapState("transactions")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get transactions:",t),[]}}async updateTransactionStatus(t,e){try{const n=(await this.getFromSnapState("transactions")||[]).map(n=>n.txId===t?{...n,status:e,confirmedAt:"confirmed"===e?(new Date).toISOString():n.confirmedAt}:n);await this.storeInSnapState("transactions",n)}catch(t){console.error("Failed to update transaction status:",t)}}async storeSignedMessage(t,e,n,a,s){const r={id:Date.now(),userId:t,sessionId:e,message:n,signature:a,messageHash:s,createdAt:(new Date).toISOString()};try{const e=await this.getSignedMessages(t);return e.unshift(r),e.length>50&&e.splice(50),await this.storeInSnapState("signedMessages",e),r}catch(t){throw console.error("Failed to store signed message:",t),t}}async getSignedMessages(t,e=25){try{return(await this.getFromSnapState("signedMessages")||[]).filter(e=>e.userId===t).slice(0,e)}catch(t){return console.error("Failed to get signed messages:",t),[]}}async storeInSnapState(t,e){const n=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...n,[t]:e}}})}async getFromSnapState(t){const e=await snap.request({method:"snap_manageState",params:{operation:"get"}});return e?.[t]}}e.TronDatabaseService=n,n.instance=null,e.tronDatabase=n.getInstance()}},e={};function n(a){var s=e[a];if(void 0!==s)return s.exports;var r=e[a]={exports:{}};return t[a](r,r.exports,n),r.exports}var a={};(()=>{var t=a;Object.defineProperty(t,"__esModule",{value:!0}),t.onRpcRequest=void 0;const e=n(360),s=n(218),r=n(328),i=n(116),o=n(848),c=new s.TronService,d=new o.TransactionPreviewService(c),u=new r.TronDAppConnector(c);t.onRpcRequest=async({origin:t,request:n})=>{try{switch(n.method){case"tron_connect":return await async function(){try{const t=await c.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Connect to TRON Network"),(0,e.text)("This will create a TRON account derived from your MetaMask seed phrase."),(0,e.divider)(),(0,e.text)("**Account Address:**"),(0,e.copyable)(t.address),(0,e.text)("**Network:**"),(0,e.text)(t.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully connected to TRON network!"}}),t;throw new Error("User rejected connection")}catch(t){throw new Error(`Failed to connect to TRON: ${t?.message||"Unknown error"}`)}}();case"tron_getAccount":return await async function(){try{return await c.getAccount()}catch(t){throw new Error(`Failed to get account: ${t?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const t=await c.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("TRON Balance"),(0,e.text)(`**Balance:** ${(0,i.formatTrx)(t)} TRX`)])}}),{balance:(0,i.formatTrx)(t),unit:"TRX"}}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(t){try{const{to:n,amount:a,memo:s}=t;if(!(0,i.validateTronAddress)(n))throw new Error("Invalid TRON address");if(!a||parseFloat(a)<=0)throw new Error("Invalid amount");const r=await c.getAccount(),o=await c.getBalance();if(parseFloat(a)>parseFloat((0,i.formatTrx)(o)))throw new Error("Insufficient balance");const u=await d.getNetworkStatus(r.network),l=await d.analyzeTransactionRisk(n,a,r.address),p=await d.simulateTransaction(n,a,r.address),h=await d.getContractDetails(n),w={from:r.address,to:n,amount:a,memo:s,estimatedFee:1,networkStatus:u,riskLevel:l,contractInteraction:h,simulationResult:p},g=await d.buildTransactionPreview(w);if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)(g)}}))throw new Error("Transaction cancelled by user");const m=await c.sendTransaction(n,a,s);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${m}`}}),{txHash:m,status:"pending"}}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_signMessage":return await async function(t){try{const{message:n}=t;if(!n)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Sign Message"),(0,e.text)("**Message to sign:**"),(0,e.text)(n),(0,e.divider)(),(0,e.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await c.signMessage(n)}}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_getTransactionHistory":return await async function(){try{const t=await c.getTransactionHistory();if(0===t.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Transaction History"),(0,e.text)("No transactions found.")])}});else{const n=t.slice(0,5).map(t=>[(0,e.text)(`**${t.type}** - ${(0,i.formatTrx)(t.amount)} TRX`),(0,e.text)(`To: ${t.to}`),(0,e.text)(`${new Date(t.timestamp).toLocaleDateString()}`),(0,e.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Recent Transactions"),...n])}})}return t}catch(t){throw new Error(`Failed to get transaction history: ${t?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(t){try{const{network:n}=t;if(!["mainnet","testnet"].includes(n))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Switch TRON Network"),(0,e.text)(`Switch to TRON ${n}?`),(0,e.divider)(),(0,e.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await c.switchNetwork(n),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${n}`}}),{network:n}}catch(t){throw new Error(`Failed to switch network: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_connect":return await async function(t){try{const{origin:e,name:n,icon:a}=t||{};if(!e||!n)throw new Error("dApp origin and name are required");const s=await u.connectDApp({origin:e,name:n,icon:a});return{connected:!0,session:{accounts:s.accounts,chainId:s.chainId,origin:s.origin,name:s.name}}}catch(t){throw new Error(`Failed to connect dApp: ${t?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_sessions":return await async function(){try{const t=u.getActiveSessions();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Active dApp Connections"),...0===t.length?[(0,e.text)("No active dApp connections.")]:t.map(t=>[(0,e.text)(`**${t.name}**`),(0,e.text)(`Origin: ${t.origin}`),(0,e.text)(`Connected: ${new Date(t.connectedAt).toLocaleString()}`),(0,e.divider)()]).flat()])}}),{sessions:t}}catch(t){throw new Error(`Failed to get sessions: ${t?.message||"Unknown error"}`)}}();case"tron_dapp_disconnect":return await async function(t){try{const{origin:e,all:n}=t||{};if(n)await u.disconnectAll();else{if(!e)throw new Error("Must specify origin or all=true");await u.disconnectDApp(e)}return{disconnected:!0}}catch(t){throw new Error(`Failed to disconnect: ${t?.message||"Unknown error"}`)}}(n.params);default:throw new Error(`Method ${n.method} not supported`)}}catch(t){throw console.error("RPC request error:",t),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${t?.message||"Unknown error"}`}}),t}}})();var s=exports;for(var r in a)s[r]=a[r];a.__esModule&&Object.defineProperty(s,"__esModule",{value:!0})})();