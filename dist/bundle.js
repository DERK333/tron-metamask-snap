(()=>{"use strict";var t={185:(t,e)=>{function a(t){return!(!t||"string"!=typeof t)&&/^T[A-Za-z0-9]{33}$/.test(t)}Object.defineProperty(e,"__esModule",{value:!0}),e.validateTronAddress=a,e.formatTrx=function(t){return(("string"==typeof t?parseFloat(t):t)/1e6).toFixed(6)},e.trxToSun=function(t){const e="string"==typeof t?parseFloat(t):t;return Math.floor(1e6*e)},e.truncateAddress=function(t,e=6,a=4){return!t||t.length<=e+a?t:`${t.slice(0,e)}...${t.slice(-a)}`},e.formatTimestamp=function(t){return new Date(t).toLocaleString()},e.validateAmount=function(t){if(!t||"string"!=typeof t)return!1;const e=parseFloat(t);return!isNaN(e)&&e>0&&e<=1e6},e.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},e.parseErrorMessage=function(t){return"string"==typeof t?t:t?.message?t.message:t?.error?t.error:"An unknown error occurred"},e.validateNetwork=function(t){return"mainnet"===t||"testnet"===t},e.formatBalance=function(t,e=6){return t.toFixed(e).replace(/\.?0+$/,"")},e.isValidTronAddress=function(t){return a(t)&&34===t.length},e.sanitizeInput=function(t){return"string"!=typeof t?"":t.trim().replace(/[<>]/g,"")},e.calculateTxFee=function(){return 1},e.checkSufficientBalance=function(t,e){return e>=parseFloat(t)+1}},360:t=>{t.exports=require("@metamask/snaps-ui")},576:t=>{t.exports=require("@metamask/key-tree")},701:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TronService=void 0;const r=a(576);e.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const t=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),e=await(0,r.getBIP44AddressKeyDeriver)(t),a=await e(195),n=this.privateKeyToAddress(a.privateKey||"");return this.account={address:n,privateKey:a.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(t){throw new Error(`Failed to connect: ${t?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!t?.tronAccount)throw new Error("No account found. Please connect first.");this.account=t.tronAccount}return this.account}async getBalance(){const t=await this.getAccount();try{const e=await this.makeRpcCall("wallet/getaccount",{address:t.address,visible:!0});return e?.balance?e.balance/1e6:0}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}async sendTransaction(t,e,a){const r=await this.getAccount();try{const a={to_address:t,owner_address:r.address,amount:Math.floor(1e6*parseFloat(e)),visible:!0},n=await this.makeRpcCall("wallet/createtransaction",a);if(!n?.txID)throw new Error("Failed to create transaction");const o=await this.signTransaction(n,r.privateKey),s=await this.makeRpcCall("wallet/broadcasttransaction",o);if(!s?.result)throw new Error(s?.message||"Transaction broadcast failed");return n.txID}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}async signMessage(t){const e=await this.getAccount();try{const a=Buffer.from(t,"utf8").toString("hex");return await this.signHex(a,e.privateKey)}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}async getTransactionHistory(){const t=await this.getAccount();try{const e=await this.makeRpcCall("v1/accounts/"+t.address+"/transactions",null,"GET");return e?.data?e.data.map(t=>({txId:t.txID||"",type:this.getTransactionType(t.raw_data?.contract?.[0]?.type||""),amount:(t.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:t.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:t.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:t.block_timestamp||0,status:t.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(t){return[]}}async switchNetwork(t){this.network=t,this.account&&(this.account.network=t,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(t,e,a="POST"){const r="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",n={method:a,headers:{"Content-Type":"application/json"}};e&&"POST"===a&&(n.body=JSON.stringify(e));const o=await fetch(`${r}/${t}`,n);if(!o.ok)throw new Error(`RPC call failed: ${o.statusText}`);return await o.json()}privateKeyToAddress(t){return"T"+this.simpleHash(t).slice(0,33)}simpleHash(t){let e=0;for(let a=0;a<t.length;a++)e=(e<<5)-e+t.charCodeAt(a),e&=e;return Math.abs(e).toString(16).padStart(33,"0")}async signTransaction(t,e){const a=await this.signHex(t.txID,e);return{...t,signature:[a]}}async signHex(t,e){return this.simpleHash(t+e)}getTransactionType(t){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract"}[t]||"Unknown"}}}},e={};function a(r){var n=e[r];if(void 0!==n)return n.exports;var o=e[r]={exports:{}};return t[r](o,o.exports,a),o.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0}),t.onRpcRequest=void 0;const e=a(360),n=a(701),o=a(185),s=new n.TronService;t.onRpcRequest=async({origin:t,request:a})=>{try{switch(a.method){case"tron_connect":return await async function(){try{const t=await s.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Connect to TRON Network"),(0,e.text)("This will create a TRON account derived from your MetaMask seed phrase."),(0,e.divider)(),(0,e.text)("**Account Address:**"),(0,e.copyable)(t.address),(0,e.text)("**Network:**"),(0,e.text)(t.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully connected to TRON network!"}}),t;throw new Error("User rejected connection")}catch(t){throw new Error(`Failed to connect to TRON: ${t?.message||"Unknown error"}`)}}();case"tron_getAccount":return await async function(){try{return await s.getAccount()}catch(t){throw new Error(`Failed to get account: ${t?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const t=await s.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("TRON Balance"),(0,e.text)(`**Balance:** ${(0,o.formatTrx)(t)} TRX`)])}}),{balance:(0,o.formatTrx)(t),unit:"TRX"}}catch(t){throw new Error(`Failed to get balance: ${t?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(t){try{const{to:a,amount:r,memo:n}=t;if(!(0,o.validateTronAddress)(a))throw new Error("Invalid TRON address");if(!r||parseFloat(r)<=0)throw new Error("Invalid amount");const i=await s.getAccount(),c=await s.getBalance();if(parseFloat(r)>parseFloat((0,o.formatTrx)(c)))throw new Error("Insufficient balance");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Confirm TRON Transaction"),(0,e.text)("**From:**"),(0,e.copyable)(i.address),(0,e.text)("**To:**"),(0,e.copyable)(a),(0,e.text)("**Amount:**"),(0,e.text)(`${r} TRX`),...n?[(0,e.text)("**Memo:**"),(0,e.text)(n)]:[],(0,e.divider)(),(0,e.text)("**Network Fee:** ~1 TRX"),(0,e.text)("**Total:** ~"+(parseFloat(r)+1).toString()+" TRX")])}}))throw new Error("Transaction cancelled by user");const u=await s.sendTransaction(a,r,n);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${u}`}}),{txHash:u,status:"pending"}}catch(t){throw new Error(`Transaction failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_signMessage":return await async function(t){try{const{message:a}=t;if(!a)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Sign Message"),(0,e.text)("**Message to sign:**"),(0,e.text)(a),(0,e.divider)(),(0,e.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await s.signMessage(a)}}catch(t){throw new Error(`Message signing failed: ${t?.message||"Unknown error"}`)}}(a.params);case"tron_getTransactionHistory":return await async function(){try{const t=await s.getTransactionHistory();if(0===t.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Transaction History"),(0,e.text)("No transactions found.")])}});else{const a=t.slice(0,5).map(t=>[(0,e.text)(`**${t.type}** - ${(0,o.formatTrx)(t.amount)} TRX`),(0,e.text)(`To: ${t.to}`),(0,e.text)(`${new Date(t.timestamp).toLocaleDateString()}`),(0,e.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,e.panel)([(0,e.heading)("Recent Transactions"),...a])}})}return t}catch(t){throw new Error(`Failed to get transaction history: ${t?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(t){try{const{network:a}=t;if(!["mainnet","testnet"].includes(a))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,e.panel)([(0,e.heading)("Switch TRON Network"),(0,e.text)(`Switch to TRON ${a}?`),(0,e.divider)(),(0,e.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await s.switchNetwork(a),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${a}`}}),{network:a}}catch(t){throw new Error(`Failed to switch network: ${t?.message||"Unknown error"}`)}}(a.params);default:throw new Error(`Method ${a.method} not supported`)}}catch(t){throw console.error("RPC request error:",t),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${t?.message||"Unknown error"}`}}),t}}})();var n=exports;for(var o in r)n[o]=r[o];r.__esModule&&Object.defineProperty(n,"__esModule",{value:!0})})();