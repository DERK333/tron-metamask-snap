(()=>{"use strict";var e={64:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.translations=void 0,t.translations={en:{"common.yes":"Yes","common.no":"No","common.confirm":"Confirm","common.cancel":"Cancel","common.continue":"Continue","common.close":"Close","common.error":"Error","common.success":"Success","common.warning":"Warning","common.trx":"TRX","common.energy":"Energy","common.bandwidth":"Bandwidth","connection.title":"Connect to TRON Network","connection.description":"This will create a TRON account derived from your MetaMask seed phrase.","connection.accountAddress":"Account Address:","connection.network":"Network:","connection.success":"Successfully connected to TRON network!","connection.rejected":"User rejected connection","connection.failed":"Failed to connect to TRON","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"Send TRON Transaction","transaction.to":"To:","transaction.from":"From:","transaction.amount":"Amount:","transaction.memo":"Memo:","transaction.estimatedFee":"Estimated Fee:","transaction.total":"Total:","transaction.success":"Transaction sent successfully!","transaction.failed":"Transaction failed","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"Low","risk.medium":"Medium","risk.high":"High","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"Unknown error","error.invalidParams":"Invalid parameters","error.userRejected":"User rejected the request","error.notConnected":"Not connected to TRON network","error.methodNotFound":"Method not found"},zh:{"common.yes":"是","common.no":"否","common.confirm":"确认","common.cancel":"取消","common.continue":"继续","common.close":"关闭","common.error":"错误","common.success":"成功","common.warning":"警告","common.trx":"TRX","common.energy":"能量","common.bandwidth":"带宽","connection.title":"连接到 TRON 网络","connection.description":"这将根据您的 MetaMask 种子短语创建一个 TRON 账户。","connection.accountAddress":"账户地址：","connection.network":"网络：","connection.success":"成功连接到 TRON 网络！","connection.rejected":"用户拒绝连接","connection.failed":"连接到 TRON 失败","account.title":"TRON 账户","account.address":"地址：","account.balance":"余额：","account.network":"网络：","account.failed":"获取账户失败","transaction.send":"发送 TRON 交易","transaction.to":"接收方：","transaction.from":"发送方：","transaction.amount":"金额：","transaction.memo":"备注：","transaction.estimatedFee":"预估费用：","transaction.total":"总计：","transaction.success":"交易发送成功！","transaction.failed":"交易失败","transaction.cancelled":"用户取消交易","transaction.invalidAddress":"无效的 TRON 地址","transaction.invalidAmount":"无效金额","transaction.insufficientBalance":"余额不足","sign.title":"签名消息","sign.message":"要签名的消息：","sign.warning":"只签名来自可信来源的消息！","sign.success":"消息签名成功！","sign.failed":"签名失败","sign.cancelled":"用户取消签名","network.switchTitle":"切换 TRON 网络","network.switchTo":"切换到 TRON {{network}}？","network.switchDescription":"这将更改您当前的网络连接。","network.switched":"已切换到 TRON {{network}}","network.invalidNetwork":'无效网络。请使用 "mainnet" 或 "testnet"',"network.switchCancelled":"用户取消网络切换","network.switchFailed":"切换网络失败","dapp.connectTitle":"连接到 {{name}}","dapp.connectDescription":"此网站想要：","dapp.viewAddress":"查看您的 TRON 地址","dapp.requestTransactions":"请求交易批准","dapp.connected":"已连接到 {{name}}","dapp.disconnected":"已断开与 {{name}} 的连接","dapp.rejected":"连接请求被拒绝","dapp.activeSessions":"活跃的 dApp 连接","dapp.noSessions":"没有活跃连接","dapp.connectedAt":"连接时间：","staking.title":"质押 TRX","staking.unstakeTitle":"解除质押 TRX","staking.amount":"您即将为 **{{resource}}** 质押 **{{amount}} TRX**。","staking.unstakeAmount":"您即将从 **{{resource}}** 解除质押 **{{amount}} TRX**。","staking.details":"质押详情：","staking.resource":"资源：","staking.lockPeriod":"锁定期：3天","staking.unstakeLockPeriod":"解除质押的 TRX 将锁定14天","staking.benefits":"好处：","staking.earnVoting":"获得投票权（1 TRX = 1 票）","staking.getFree":"获得免费的{{resource}}用于交易","staking.supportNetwork":"支持 TRON 网络","staking.loseVoting":"您将失去此金额的投票权","staking.reducedResource":"免费{{resource}}将减少","staking.success":"成功为{{resource}}质押{{amount}} TRX","staking.unstakeSuccess":"成功从{{resource}}解除质押{{amount}} TRX","staking.cancelled":"用户取消质押","staking.unstakeCancelled":"用户取消解除质押","staking.failed":"质押失败","staking.unstakeFailed":"解除质押失败","staking.invalidAmount":"无效的质押金额","staking.invalidResource":"无效的资源类型","stakingInfo.title":"质押信息","stakingInfo.stakedBalance":"质押余额：","stakingInfo.total":"总计：","stakingInfo.forEnergy":"能量质押：","stakingInfo.forBandwidth":"带宽质押：","stakingInfo.votingPower":"投票权：","stakingInfo.available":"可用：","stakingInfo.activeVotes":"活跃投票：","stakingInfo.noVotes":"没有活跃投票","stakingInfo.rewards":"奖励：","stakingInfo.votes":"票","voting.title":"为超级代表投票","voting.description":"使用您的投票权支持超级代表","voting.selectedSR":"选定的 SR：","voting.currentVotes":"当前票数：","voting.votesToCast":"投票数：","voting.availableVotes":"可用票数：","voting.success":"成功为{{name}}投{{votes}}票","voting.cancelled":"用户取消投票","voting.failed":"投票失败","voting.insufficientVotes":"投票权不足","voting.invalidVotes":"无效的投票数","sr.title":"顶级超级代表","sr.description":"为 SR 投票以获得奖励并支持网络","sr.votes":"票数：","sr.productivity":"生产率：","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... 以及更多","withdrawal.title":"提取过期余额","withdrawal.available":"可提取：","withdrawal.description":"这将提取所有过期的解冻余额到您的账户。","withdrawal.success":"成功提取{{amount}} TRX","withdrawal.nothingToWithdraw":"没有过期余额可提取","withdrawal.cancelled":"用户取消提取","withdrawal.failed":"提取失败","preview.networkStatus":"网络状态","preview.congestion":"拥堵度：","preview.blockTime":"出块时间：","preview.currentBlock":"当前区块：","preview.riskAssessment":"风险评估","preview.level":"风险等级：","preview.warnings":"警告：","preview.feeEstimation":"费用估算","preview.estimatedCost":"预估成本：","preview.energyRequired":"所需能量：","preview.bandwidthRequired":"所需带宽：","preview.contractInteraction":"合约交互","preview.contractType":"合约类型：","preview.method":"方法：","preview.simulation":"交易模拟","preview.simulationSuccess":"模拟成功","preview.simulationFailed":"模拟失败","preview.energyUsed":"使用的能量：","preview.bandwidthUsed":"使用的带宽：","risk.low":"低","risk.medium":"中","risk.high":"高","risk.veryHighAmount":"交易金额非常高","risk.newAddress":"接收方是没有历史记录的新地址","risk.contractUnverified":"与未验证的合约交互","risk.insufficientBalance":"余额不足以支付交易和费用","error.unknown":"未知错误","error.invalidParams":"无效参数","error.userRejected":"用户拒绝请求","error.notConnected":"未连接到 TRON 网络","error.methodNotFound":"找不到方法"},es:{"common.yes":"Sí","common.no":"No","common.confirm":"Confirmar","common.cancel":"Cancelar","common.continue":"Continuar","common.close":"Cerrar","common.error":"Error","common.success":"Éxito","common.warning":"Advertencia","common.trx":"TRX","common.energy":"Energía","common.bandwidth":"Ancho de banda","connection.title":"Conectar a la Red TRON","connection.description":"Esto creará una cuenta TRON derivada de su frase semilla de MetaMask.","connection.accountAddress":"Dirección de cuenta:","connection.network":"Red:","connection.success":"¡Conectado exitosamente a la red TRON!","connection.rejected":"Usuario rechazó la conexión","connection.failed":"Error al conectar a TRON","account.title":"Cuenta TRON","account.address":"Dirección:","account.balance":"Saldo:","account.network":"Red:","account.failed":"Error al obtener cuenta","transaction.send":"Enviar Transacción TRON","transaction.to":"Para:","transaction.from":"De:","transaction.amount":"Cantidad:","transaction.memo":"Memo:","transaction.estimatedFee":"Tarifa estimada:","transaction.total":"Total:","transaction.success":"¡Transacción enviada con éxito!","transaction.failed":"Transacción fallida","transaction.cancelled":"Transacción cancelada por usuario","transaction.invalidAddress":"Dirección TRON inválida","transaction.invalidAmount":"Cantidad inválida","transaction.insufficientBalance":"Saldo insuficiente","sign.title":"Firmar Mensaje","sign.message":"Mensaje a firmar:","sign.warning":"¡Solo firme mensajes de fuentes confiables!","sign.success":"¡Mensaje firmado exitosamente!","sign.failed":"Error al firmar mensaje","sign.cancelled":"Firma cancelada por usuario","network.switchTitle":"Cambiar Red TRON","network.switchTo":"¿Cambiar a TRON {{network}}?","network.switchDescription":"Esto cambiará su conexión de red actual.","network.switched":"Cambiado a TRON {{network}}","network.invalidNetwork":'Red inválida. Use "mainnet" o "testnet"',"network.switchCancelled":"Cambio de red cancelado por usuario","network.switchFailed":"Error al cambiar red","dapp.connectTitle":"Conectar a {{name}}","dapp.connectDescription":"Este sitio desea:","dapp.viewAddress":"Ver su dirección TRON","dapp.requestTransactions":"Solicitar aprobaciones de transacciones","dapp.connected":"Conectado a {{name}}","dapp.disconnected":"Desconectado de {{name}}","dapp.rejected":"Solicitud de conexión rechazada","dapp.activeSessions":"Conexiones dApp Activas","dapp.noSessions":"Sin conexiones activas","dapp.connectedAt":"Conectado:","staking.title":"Apostar TRX","staking.unstakeTitle":"Desapostar TRX","staking.amount":"Está a punto de apostar **{{amount}} TRX** para **{{resource}}**.","staking.unstakeAmount":"Está a punto de desapostar **{{amount}} TRX** de **{{resource}}**.","staking.details":"Detalles de Apuesta:","staking.resource":"Recurso:","staking.lockPeriod":"Período de bloqueo: 3 días","staking.unstakeLockPeriod":"TRX desapostado estará bloqueado por 14 días","staking.benefits":"Beneficios:","staking.earnVoting":"Ganar derechos de voto (1 TRX = 1 voto)","staking.getFree":"Obtener {{resource}} gratis para transacciones","staking.supportNetwork":"Apoyar la red TRON","staking.loseVoting":"Perderá derechos de voto por esta cantidad","staking.reducedResource":"{{resource}} gratis se reducirá","staking.success":"Apostado exitosamente {{amount}} TRX para {{resource}}","staking.unstakeSuccess":"Desapostado exitosamente {{amount}} TRX de {{resource}}","staking.cancelled":"Apuesta cancelada por usuario","staking.unstakeCancelled":"Desapuesta cancelada por usuario","staking.failed":"Apuesta fallida","staking.unstakeFailed":"Desapuesta fallida","staking.invalidAmount":"Cantidad de apuesta inválida","staking.invalidResource":"Tipo de recurso inválido","stakingInfo.title":"Información de Apuesta","stakingInfo.stakedBalance":"Saldo Apostado:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"Para Energía:","stakingInfo.forBandwidth":"Para Ancho de Banda:","stakingInfo.votingPower":"Poder de Voto:","stakingInfo.available":"Disponible:","stakingInfo.activeVotes":"Votos Activos:","stakingInfo.noVotes":"Sin votos activos","stakingInfo.rewards":"Recompensas:","stakingInfo.votes":"votos","voting.title":"Votar por Super Representantes","voting.description":"Use su poder de voto para apoyar Super Representantes","voting.selectedSR":"SR seleccionado:","voting.currentVotes":"Votos actuales:","voting.votesToCast":"Votos a emitir:","voting.availableVotes":"Votos disponibles:","voting.success":"Votado exitosamente {{votes}} para {{name}}","voting.cancelled":"Votación cancelada por usuario","voting.failed":"Votación fallida","voting.insufficientVotes":"Poder de voto insuficiente","voting.invalidVotes":"Recuento de votos inválido","sr.title":"Top Super Representantes","sr.description":"Vote por SRs para ganar recompensas y apoyar la red","sr.votes":"Votos:","sr.productivity":"Productividad:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... y más","withdrawal.title":"Retirar Saldo Expirado","withdrawal.available":"Disponible para retirar:","withdrawal.description":"Esto retirará todo el saldo descongelado expirado a su cuenta.","withdrawal.success":"Retirado exitosamente {{amount}} TRX","withdrawal.nothingToWithdraw":"Sin saldo expirado para retirar","withdrawal.cancelled":"Retiro cancelado por usuario","withdrawal.failed":"Retiro fallido","preview.networkStatus":"Estado de Red","preview.congestion":"Congestión:","preview.blockTime":"Tiempo de Bloque:","preview.currentBlock":"Bloque Actual:","preview.riskAssessment":"Evaluación de Riesgo","preview.level":"Nivel de Riesgo:","preview.warnings":"Advertencias:","preview.feeEstimation":"Estimación de Tarifa","preview.estimatedCost":"Costo Estimado:","preview.energyRequired":"Energía Requerida:","preview.bandwidthRequired":"Ancho de Banda Requerido:","preview.contractInteraction":"Interacción de Contrato","preview.contractType":"Tipo de Contrato:","preview.method":"Método:","preview.simulation":"Simulación de Transacción","preview.simulationSuccess":"Simulación exitosa","preview.simulationFailed":"Simulación fallida","preview.energyUsed":"Energía usada:","preview.bandwidthUsed":"Ancho de banda usado:","risk.low":"Bajo","risk.medium":"Medio","risk.high":"Alto","risk.veryHighAmount":"Cantidad de transacción muy alta","risk.newAddress":"Destinatario es una dirección nueva sin historial","risk.contractUnverified":"Interactuando con contrato no verificado","risk.insufficientBalance":"Saldo insuficiente para transacción + tarifas","error.unknown":"Error desconocido","error.invalidParams":"Parámetros inválidos","error.userRejected":"Usuario rechazó la solicitud","error.notConnected":"No conectado a red TRON","error.methodNotFound":"Método no encontrado"},fr:{"common.yes":"Oui","common.no":"Non","common.confirm":"Confirmer","common.cancel":"Annuler","common.continue":"Continuer","common.close":"Fermer","common.error":"Erreur","common.success":"Succès","common.warning":"Avertissement","common.trx":"TRX","common.energy":"Énergie","common.bandwidth":"Bande passante","connection.title":"Connexion au Réseau TRON","connection.description":"Cela créera un compte TRON dérivé de votre phrase de récupération MetaMask.","connection.accountAddress":"Adresse du compte:","connection.network":"Réseau:","connection.success":"Connecté avec succès au réseau TRON!","connection.rejected":"Connexion refusée par l'utilisateur","connection.failed":"Échec de la connexion à TRON","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"Envoyer une Transaction TRON","transaction.to":"À:","transaction.from":"De:","transaction.amount":"Montant:","transaction.memo":"Memo:","transaction.estimatedFee":"Frais estimés:","transaction.total":"Total:","transaction.success":"Transaction envoyée avec succès!","transaction.failed":"Transaction échouée","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"Low","risk.medium":"Medium","risk.high":"High","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"Erreur inconnue","error.invalidParams":"Paramètres invalides","error.userRejected":"Demande rejetée par l'utilisateur","error.notConnected":"Non connecté au réseau TRON","error.methodNotFound":"Méthode non trouvée"},ja:{"common.yes":"はい","common.no":"いいえ","common.confirm":"確認","common.cancel":"キャンセル","common.continue":"続行","common.close":"閉じる","common.error":"エラー","common.success":"成功","common.warning":"警告","common.trx":"TRX","common.energy":"エネルギー","common.bandwidth":"帯域幅","connection.title":"TRONネットワークに接続","connection.description":"MetaMaskのシードフレーズから派生したTRONアカウントを作成します。","connection.accountAddress":"アカウントアドレス：","connection.network":"ネットワーク：","connection.success":"TRONネットワークに正常に接続しました！","connection.rejected":"ユーザーが接続を拒否しました","connection.failed":"TRONへの接続に失敗しました","account.title":"TRON Account","account.address":"Address:","account.balance":"Balance:","account.network":"Network:","account.failed":"Failed to get account","transaction.send":"TRONトランザクションを送信","transaction.to":"宛先：","transaction.from":"送信元：","transaction.amount":"金額：","transaction.memo":"Memo:","transaction.estimatedFee":"Estimated Fee:","transaction.total":"Total:","transaction.success":"トランザクションが正常に送信されました！","transaction.failed":"トランザクションが失敗しました","transaction.cancelled":"Transaction cancelled by user","transaction.invalidAddress":"Invalid TRON address","transaction.invalidAmount":"Invalid amount","transaction.insufficientBalance":"Insufficient balance","sign.title":"Sign Message","sign.message":"Message to sign:","sign.warning":"Only sign messages from trusted sources!","sign.success":"Message signed successfully!","sign.failed":"Failed to sign message","sign.cancelled":"Signing cancelled by user","network.switchTitle":"Switch TRON Network","network.switchTo":"Switch to TRON {{network}}?","network.switchDescription":"This will change your current network connection.","network.switched":"Switched to TRON {{network}}","network.invalidNetwork":'Invalid network. Use "mainnet" or "testnet"',"network.switchCancelled":"Network switch cancelled by user","network.switchFailed":"Failed to switch network","dapp.connectTitle":"Connect to {{name}}","dapp.connectDescription":"This site wants to:","dapp.viewAddress":"View your TRON address","dapp.requestTransactions":"Request transaction approvals","dapp.connected":"Connected to {{name}}","dapp.disconnected":"Disconnected from {{name}}","dapp.rejected":"Connection request rejected","dapp.activeSessions":"Active dApp Connections","dapp.noSessions":"No active connections","dapp.connectedAt":"Connected:","staking.title":"Stake TRX","staking.unstakeTitle":"Unstake TRX","staking.amount":"You are about to stake **{{amount}} TRX** for **{{resource}}**.","staking.unstakeAmount":"You are about to unstake **{{amount}} TRX** from **{{resource}}**.","staking.details":"Staking Details:","staking.resource":"Resource:","staking.lockPeriod":"Lock Period: 3 days","staking.unstakeLockPeriod":"Unstaked TRX will be locked for 14 days","staking.benefits":"Benefits:","staking.earnVoting":"Earn voting rights (1 TRX = 1 vote)","staking.getFree":"Get free {{resource}} for transactions","staking.supportNetwork":"Support the TRON network","staking.loseVoting":"You will lose voting rights for this amount","staking.reducedResource":"Free {{resource}} will be reduced","staking.success":"Successfully staked {{amount}} TRX for {{resource}}","staking.unstakeSuccess":"Successfully unstaked {{amount}} TRX from {{resource}}","staking.cancelled":"Staking cancelled by user","staking.unstakeCancelled":"Unstaking cancelled by user","staking.failed":"Staking failed","staking.unstakeFailed":"Unstaking failed","staking.invalidAmount":"Invalid staking amount","staking.invalidResource":"Invalid resource type","stakingInfo.title":"Staking Information","stakingInfo.stakedBalance":"Staked Balance:","stakingInfo.total":"Total:","stakingInfo.forEnergy":"For Energy:","stakingInfo.forBandwidth":"For Bandwidth:","stakingInfo.votingPower":"Voting Power:","stakingInfo.available":"Available:","stakingInfo.activeVotes":"Active Votes:","stakingInfo.noVotes":"No active votes","stakingInfo.rewards":"Rewards:","stakingInfo.votes":"votes","voting.title":"Vote for Super Representatives","voting.description":"Use your voting power to support Super Representatives","voting.selectedSR":"Selected SR:","voting.currentVotes":"Current votes:","voting.votesToCast":"Votes to cast:","voting.availableVotes":"Available votes:","voting.success":"Successfully voted {{votes}} for {{name}}","voting.cancelled":"Voting cancelled by user","voting.failed":"Voting failed","voting.insufficientVotes":"Insufficient voting power","voting.invalidVotes":"Invalid vote count","sr.title":"Top Super Representatives","sr.description":"Vote for SRs to earn rewards and support the network","sr.votes":"Votes:","sr.productivity":"Productivity:","sr.ranking":"#{{rank}} {{name}}","sr.andMore":"... and more","withdrawal.title":"Withdraw Expired Balance","withdrawal.available":"Available to withdraw:","withdrawal.description":"This will withdraw all expired unfrozen balance to your account.","withdrawal.success":"Successfully withdrew {{amount}} TRX","withdrawal.nothingToWithdraw":"No expired balance to withdraw","withdrawal.cancelled":"Withdrawal cancelled by user","withdrawal.failed":"Withdrawal failed","preview.networkStatus":"Network Status","preview.congestion":"Congestion:","preview.blockTime":"Block Time:","preview.currentBlock":"Current Block:","preview.riskAssessment":"Risk Assessment","preview.level":"Risk Level:","preview.warnings":"Warnings:","preview.feeEstimation":"Fee Estimation","preview.estimatedCost":"Estimated Cost:","preview.energyRequired":"Energy Required:","preview.bandwidthRequired":"Bandwidth Required:","preview.contractInteraction":"Contract Interaction","preview.contractType":"Contract Type:","preview.method":"Method:","preview.simulation":"Transaction Simulation","preview.simulationSuccess":"Simulation successful","preview.simulationFailed":"Simulation failed","preview.energyUsed":"Energy used:","preview.bandwidthUsed":"Bandwidth used:","risk.low":"低","risk.medium":"中","risk.high":"高","risk.veryHighAmount":"Very high transaction amount","risk.newAddress":"Recipient is a new address with no history","risk.contractUnverified":"Interacting with unverified contract","risk.insufficientBalance":"Insufficient balance for transaction + fees","error.unknown":"不明なエラー","error.invalidParams":"無効なパラメータ","error.userRejected":"ユーザーがリクエストを拒否しました","error.notConnected":"TRONネットワークに接続されていません","error.methodNotFound":"メソッドが見つかりません"}}},116:(e,t)=>{function n(e){return!(!e||"string"!=typeof e)&&/^T[A-Za-z0-9]{33}$/.test(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.validateTronAddress=n,t.formatTrx=function(e){return(("string"==typeof e?parseFloat(e):e)/1e6).toFixed(6)},t.trxToSun=function(e){const t="string"==typeof e?parseFloat(e):e;return Math.floor(1e6*t)},t.truncateAddress=function(e,t=6,n=4){return!e||e.length<=t+n?e:`${e.slice(0,t)}...${e.slice(-n)}`},t.formatTimestamp=function(e){return new Date(e).toLocaleString()},t.validateAmount=function(e){if(!e||"string"!=typeof e)return!1;const t=parseFloat(e);return!isNaN(t)&&t>0&&t<=1e6},t.generateTxId=function(){return Array.from({length:64},()=>Math.floor(16*Math.random()).toString(16)).join("")},t.parseErrorMessage=function(e){return"string"==typeof e?e:e?.message?e.message:e?.error?e.error:"An unknown error occurred"},t.validateNetwork=function(e){return"mainnet"===e||"testnet"===e},t.formatBalance=function(e,t=6){return e.toFixed(t).replace(/\.?0+$/,"")},t.isValidTronAddress=function(e){return n(e)&&34===e.length},t.sanitizeInput=function(e){return"string"!=typeof e?"":e.trim().replace(/[<>]/g,"")},t.calculateTxFee=function(){return 1},t.checkSufficientBalance=function(e,t){return t>=parseFloat(e)+1}},218:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TronService=void 0;const a=n(576);t.TronService=class{constructor(){this.network="mainnet",this.account=null}async connect(){try{const e=await snap.request({method:"snap_getEntropy",params:{version:1,salt:"tron-snap-salt"}}),t=await(0,a.getBIP44AddressKeyDeriver)(e),n=await t(195),s=this.privateKeyToAddress(n.privateKey||"");return this.account={address:s,privateKey:n.privateKey||"",network:this.network},await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}),this.account}catch(e){throw new Error(`Failed to connect: ${e?.message||"Unknown error"}`)}}async getAccount(){if(!this.account){const e=await snap.request({method:"snap_manageState",params:{operation:"get"}});if(!e?.tronAccount)throw new Error("No account found. Please connect first.");this.account=e.tronAccount}return this.account}async getBalance(){const e=await this.getAccount();try{const t=await this.makeRpcCall("wallet/getaccount",{address:e.address,visible:!0});return t?.balance?t.balance/1e6:0}catch(e){throw new Error(`Failed to get balance: ${e?.message||"Unknown error"}`)}}async sendTransaction(e,t,n){const a=await this.getAccount();try{const n={to_address:e,owner_address:a.address,amount:Math.floor(1e6*parseFloat(t)),visible:!0},s=await this.makeRpcCall("wallet/createtransaction",n);if(!s?.txID)throw new Error("Failed to create transaction");const r=await this.signTransaction(s,a.privateKey),o=await this.makeRpcCall("wallet/broadcasttransaction",r);if(!o?.result)throw new Error(o?.message||"Transaction broadcast failed");return s.txID}catch(e){throw new Error(`Transaction failed: ${e?.message||"Unknown error"}`)}}async signMessage(e){const t=await this.getAccount();try{const n=Buffer.from(e,"utf8").toString("hex");return await this.signHex(n,t.privateKey)}catch(e){throw new Error(`Message signing failed: ${e?.message||"Unknown error"}`)}}async getTransactionHistory(){const e=await this.getAccount();try{const t=await this.makeRpcCall("v1/accounts/"+e.address+"/transactions",null,"GET");return t?.data?t.data.map(e=>({txId:e.txID||"",type:this.getTransactionType(e.raw_data?.contract?.[0]?.type||""),amount:(e.raw_data?.contract?.[0]?.parameter?.value?.amount||0)/1e6,to:e.raw_data?.contract?.[0]?.parameter?.value?.to_address||"",from:e.raw_data?.contract?.[0]?.parameter?.value?.owner_address||"",timestamp:e.block_timestamp||0,status:e.ret?.[0]?.contractRet||"SUCCESS"})):[]}catch(e){return[]}}async switchNetwork(e){this.network=e,this.account&&(this.account.network=e,await snap.request({method:"snap_manageState",params:{operation:"update",newState:{tronAccount:{address:this.account.address,privateKey:this.account.privateKey,network:this.account.network}}}}))}async makeRpcCall(e,t,n="POST"){const a="mainnet"===this.network?"https://api.trongrid.io":"https://api.shasta.trongrid.io",s={method:n,headers:{"Content-Type":"application/json"}};t&&"POST"===n&&(s.body=JSON.stringify(t));const r=await fetch(`${a}/${e}`,s);if(!r.ok)throw new Error(`RPC call failed: ${r.statusText}`);return await r.json()}privateKeyToAddress(e){return"T"+this.simpleHash(e).slice(0,33)}simpleHash(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t&=t;return Math.abs(t).toString(16).padStart(33,"0")}async signTransaction(e,t){const n=await this.signHex(e.txID,t);return{...e,signature:[n]}}async signHex(e,t){return this.simpleHash(e+t)}getTransactionType(e){return{TransferContract:"Transfer",TransferAssetContract:"Transfer Asset",TriggerSmartContract:"Smart Contract",CreateSmartContract:"Deploy Contract",FreezeBalanceV2Contract:"Stake TRX",UnfreezeBalanceV2Contract:"Unstake TRX",VoteWitnessContract:"Vote for SR",WithdrawExpireUnfreezeContract:"Withdraw Unstaked"}[e]||"Unknown"}async stakeTRX(e,t,n=3){if(!this.account)throw new Error("Not connected");const a=Math.round(1e6*parseFloat(e)),s={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,frozen_balance:a,resource:t,frozen_duration:n},type_url:"type.googleapis.com/protocol.FreezeBalanceV2Contract"},type:"FreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`stake-${this.account.address}-${e}-${Date.now()}`)},r=await this.signTransaction(s,this.account.privateKey),o=await this.makeRpcCall("/wallet/broadcasttransaction",r);return o?.txid||s.txID}async unstakeTRX(e,t){if(!this.account)throw new Error("Not connected");const n=Math.round(1e6*parseFloat(e)),a={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,unfreeze_balance:n,resource:t},type_url:"type.googleapis.com/protocol.UnfreezeBalanceV2Contract"},type:"UnfreezeBalanceV2Contract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`unstake-${this.account.address}-${e}-${Date.now()}`)},s=await this.signTransaction(a,this.account.privateKey),r=await this.makeRpcCall("/wallet/broadcasttransaction",s);return r?.txid||a.txID}async voteForSR(e){if(!this.account)throw new Error("Not connected");const t={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address,votes:e.map(e=>({vote_address:e.address,vote_count:e.count}))},type_url:"type.googleapis.com/protocol.VoteWitnessContract"},type:"VoteWitnessContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`vote-${this.account.address}-${JSON.stringify(e)}-${Date.now()}`)},n=await this.signTransaction(t,this.account.privateKey),a=await this.makeRpcCall("/wallet/broadcasttransaction",n);return a?.txid||t.txID}async getStakingInfo(){if(!this.account)throw new Error("Not connected");try{const e=await this.makeRpcCall("/wallet/getaccountresource",{address:this.account.address},"POST"),t=(await this.makeRpcCall("/wallet/getdelegatedresourceaccountindexv2",{value:this.account.address},"POST"),await this.makeRpcCall("/wallet/getaccount",{address:this.account.address},"POST")),n=e?.frozen_balance_for_energy||0,a=e?.frozen_balance_for_bandwidth||0;return{frozen:(n+a)/1e6,frozenEnergy:n/1e6,frozenBandwidth:a/1e6,votes:t?.votes?.map(e=>({address:e.vote_address,name:`SR ${e.vote_address.substring(0,10)}...`,votes:e.vote_count}))||[],rewards:0,canUnfreezeIn:0}}catch(e){return{frozen:0,frozenEnergy:0,frozenBandwidth:0,votes:[],rewards:0,canUnfreezeIn:0}}}async getSuperRepresentatives(){try{const e=await this.makeRpcCall("/wallet/listwitnesses",{},"POST");return e?.witnesses?e.witnesses.map((e,t)=>({address:e.address,name:e.url||`SR #${t+1}`,url:e.url||"",totalVotes:e.voteCount||0,totalProduced:e.totalProduced||0,ranking:t+1,productivity:e.totalProduced>0?e.totalProduced/(e.totalProduced+e.totalMissed||0)*100:0})).slice(0,27):this.getMockSuperRepresentatives()}catch(e){return this.getMockSuperRepresentatives()}}getMockSuperRepresentatives(){return[{address:"TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH",name:"Binance Staking",url:"https://binance.com",totalVotes:1615e7,totalProduced:15e5,ranking:1,productivity:99.5},{address:"TZ6p83xJA9kFZYRXfkKGgqwrqmFgDvbRds",name:"Poloniex",url:"https://poloniex.com",totalVotes:1452e7,totalProduced:145e4,ranking:2,productivity:99.2},{address:"TEVAq6pqDSNmE8Q8nC9qDQAA6VeF9Kux5Y",name:"TRONScan",url:"https://tronscan.org",totalVotes:128e8,totalProduced:142e4,ranking:3,productivity:99.8}]}async withdrawExpiredUnfrozen(){if(!this.account)throw new Error("Not connected");const e={raw_data:{contract:[{parameter:{value:{owner_address:this.account.address},type_url:"type.googleapis.com/protocol.WithdrawExpireUnfreezeContract"},type:"WithdrawExpireUnfreezeContract"}],ref_block_bytes:"0000",ref_block_hash:"0000000000000000",expiration:Date.now()+6e4,timestamp:Date.now()},txID:this.simpleHash(`withdraw-${this.account.address}-${Date.now()}`)},t=await this.signTransaction(e,this.account.privateKey),n=await this.makeRpcCall("/wallet/broadcasttransaction",t);return n?.txid||e.txID}}},328:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TronDAppConnector=void 0;const a=n(360),s=n(940),r=n(848);t.TronDAppConnector=class{constructor(e){this.activeSessions=new Map,this.globalTronObject=null,this.currentUser=null,this.tronService=e,this.previewService=new r.TransactionPreviewService(e),this.initializeGlobalTronObject(),this.initializeDatabase()}async initializeDatabase(){try{await s.tronDatabase.initialize()}catch(e){console.warn("Database initialization failed, using snap state only:",e)}}initializeGlobalTronObject(){this.globalTronObject={isTronLink:!0,isMetaMaskTron:!0,ready:!0,request:this.handleDAppRequest.bind(this),isConnected:this.isConnected.bind(this),requestAccounts:()=>this.handleDAppRequest({method:"tron_requestAccounts"}),getAccount:()=>this.handleDAppRequest({method:"tron_getAccount"}),signMessage:e=>this.handleDAppRequest({method:"tron_signMessage",params:{message:e}}),signTransaction:e=>this.handleDAppRequest({method:"tron_signTransaction",params:e}),sendTransaction:e=>this.handleDAppRequest({method:"tron_sendTransaction",params:e}),chainId:728126428,networkVersion:"mainnet",on:this.addEventListener.bind(this),removeListener:this.removeEventListener.bind(this),selectedAddress:null,accounts:[]}}async connectDApp(e){try{if(!await this.showConnectionApproval(e))throw new Error("User rejected connection");const t=await this.tronService.getAccount();await this.ensureUserExists(t.address,t.network),await s.tronDatabase.storeDAppSession(this.currentUser.id,e.origin,e.name,e.icon,"mainnet"===t.network?728126428:2494104990);const n={connected:!0,origin:e.origin,name:e.name,icon:e.icon,accounts:[t.address],chainId:"mainnet"===t.network?728126428:2494104990,connectedAt:Date.now()};return this.activeSessions.set(e.origin,n),this.updateGlobalTronObject(t),await this.notifyUser(`Connected to ${e.name} successfully!`),n}catch(e){throw new Error(`Failed to connect dApp: ${e?.message||"Unknown error"}`)}}async ensureUserExists(e,t){this.currentUser||(this.currentUser=await s.tronDatabase.getUser(e),this.currentUser||(this.currentUser=await s.tronDatabase.storeUser(e,t)))}async handleDAppRequest(e){const{method:t,params:n,origin:a}=e;if(a&&!this.activeSessions.has(a))throw new Error("dApp not connected. Please connect first.");switch(t){case"tron_requestAccounts":return await this.requestAccounts();case"tron_getAccount":return await this.getAccount();case"tron_getBalance":return await this.getBalance();case"tron_signMessage":return await this.signMessage(n);case"tron_signTransaction":return await this.signTransaction(n);case"tron_sendTransaction":return await this.sendTransaction(n);case"tron_switchNetwork":return await this.switchNetwork(n);default:throw new Error(`Unsupported method: ${t}`)}}async requestAccounts(){try{return[(await this.tronService.getAccount()).address]}catch(e){throw new Error("Failed to get accounts")}}async getAccount(){return await this.tronService.getAccount()}async getBalance(){return await this.tronService.getBalance()}async signMessage(e){const{message:t}=e;if(!await this.showSigningApproval(t))throw new Error("User rejected message signing");return await this.tronService.signMessage(t)}async signTransaction(e){if(!await this.showTransactionApproval(e,"sign"))throw new Error("User rejected transaction signing");const t=await this.tronService.getAccount();return await this.tronService.signTransaction(e,t.privateKey)}async sendTransaction(e){if(!await this.showTransactionApproval(e,"send"))throw new Error("User rejected transaction");return await this.tronService.sendTransaction(e.to||e.to_address,e.amount||e.value,e.data)}async switchNetwork(e){await this.tronService.switchNetwork(e.network);for(const t of this.activeSessions.values())t.chainId="mainnet"===e.network?728126428:2494104990}isConnected(){return this.activeSessions.size>0}getActiveSessions(){return Array.from(this.activeSessions.values())}async disconnectDApp(e){this.activeSessions.delete(e),await this.notifyUser(`Disconnected from ${e}`)}async disconnectAll(){this.activeSessions.clear(),this.updateGlobalTronObject(null),await this.notifyUser("Disconnected from all dApps")}updateGlobalTronObject(e){this.globalTronObject&&(this.globalTronObject.selectedAddress=e?.address||null,this.globalTronObject.accounts=e?[e.address]:[],this.globalTronObject.chainId="mainnet"===e?.network?728126428:2494104990,this.globalTronObject.networkVersion=e?.network||"mainnet")}async showConnectionApproval(e){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("dApp Connection Request"),(0,a.text)(`**${e.name}** wants to connect to your TRON wallet.`),(0,a.divider)(),(0,a.text)("**Origin:**"),(0,a.text)(e.origin),(0,a.divider)(),(0,a.text)("This will allow the dApp to:"),(0,a.text)("• View your TRON address"),(0,a.text)("• Request transaction signatures"),(0,a.text)("• Send transaction requests"),(0,a.text)("• View your balance"),(0,a.divider)(),(0,a.text)("⚠️ Only connect to dApps you trust.")])}})}async showSigningApproval(e){return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)([(0,a.heading)("Sign Message Request"),(0,a.text)("A dApp is requesting you to sign a message:"),(0,a.divider)(),(0,a.text)("**Message:**"),(0,a.copyable)(e),(0,a.divider)(),(0,a.text)("⚠️ Only sign messages you trust and understand.")])}})}async showTransactionApproval(e,t){const n=await this.tronService.getAccount(),s=e.to||e.to_address||"Unknown",r=e.value||e.amount||"0",o=await this.previewService.getNetworkStatus(n.network),i=await this.previewService.analyzeTransactionRisk(s,r,n.address),c=await this.previewService.simulateTransaction(s,r,n.address),d=await this.previewService.getContractDetails(s,e.data),l={from:n.address,to:s,amount:r,memo:e.data,estimatedFee:1,networkStatus:o,riskLevel:i,contractInteraction:d,simulationResult:c},u=await this.previewService.buildTransactionPreview(l),w=[(0,a.heading)(`🔐 ${"sign"===t?"Sign":"Send"} Transaction Request`),(0,a.text)(`**dApp:** ${this.activeSessions.get(e.origin)?.name||"Unknown"}`),(0,a.divider)(),...u];return!!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,a.panel)(w)}})}addEventListener(e,t){console.log(`Event listener added for: ${e}`)}removeEventListener(e,t){console.log(`Event listener removed for: ${e}`)}async notifyUser(e){await snap.request({method:"snap_notify",params:{type:"inApp",message:e}})}}},360:e=>{e.exports=require("@metamask/snaps-ui")},484:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.i18n=t.I18nService=void 0;const a=n(64);class s{static getInstance(){return s.instance||(s.instance=new s),s.instance}constructor(){this.currentLanguage="en",this.initializeLanguage()}async initializeLanguage(){try{const e=await snap.request({method:"snap_manageState",params:{operation:"get"}}),t=e?.userLanguage;t&&"string"==typeof t&&this.isValidLanguage(t)?this.currentLanguage=t:this.currentLanguage=this.detectBrowserLanguage()}catch(e){console.error("Failed to initialize language:",e),this.currentLanguage="en"}}detectBrowserLanguage(){return"en"}isValidLanguage(e){return e in a.translations}getLanguage(){return this.currentLanguage}async setLanguage(e){if(!this.isValidLanguage(e))throw new Error(`Unsupported language: ${e}`);this.currentLanguage=e;try{const t=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...t,userLanguage:e}}})}catch(e){console.error("Failed to persist language preference:",e)}}t(e,t){const n=a.translations[this.currentLanguage],s=a.translations.en,r=n?.[e]||s?.[e]||e;return t&&"string"==typeof r?Object.entries(t).reduce((e,[t,n])=>e.replace(new RegExp(`{{${t}}}`,"g"),n),r):r}getAvailableLanguages(){return[{code:"en",name:"English"},{code:"zh",name:"中文"},{code:"es",name:"Español"},{code:"fr",name:"Français"},{code:"ja",name:"日本語"}]}}t.I18nService=s,s.instance=null,t.i18n=s.getInstance()},576:e=>{e.exports=require("@metamask/key-tree")},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TransactionPreviewService=void 0;const a=n(360),s=n(116);t.TransactionPreviewService=class{constructor(e){this.tronService=e}async buildTransactionPreview(e){const t=[];return t.push((0,a.heading)("🔍 Transaction Preview"),(0,a.divider)()),t.push((0,a.text)("**📤 From:**"),(0,a.copyable)(e.from),(0,a.text)("**📥 To:**"),(0,a.copyable)(e.to),(0,a.text)("**💰 Amount:**"),(0,a.text)(`${e.amount} TRX`),(0,a.divider)()),e.memo&&t.push((0,a.text)("**📝 Memo:**"),(0,a.text)(e.memo),(0,a.divider)()),e.networkStatus&&t.push(...this.buildNetworkStatus(e.networkStatus)),e.riskLevel&&t.push(...this.buildRiskAssessment(e.riskLevel)),t.push(...this.buildFeeEstimation(e.estimatedFee||(0,s.calculateTxFee)())),e.contractInteraction?.isContract&&t.push(...this.buildContractDetails(e.contractInteraction)),e.simulationResult&&t.push(...this.buildSimulationResults(e.simulationResult)),t.push((0,a.divider)(),(0,a.text)("**📊 Transaction Summary:**"),(0,a.text)(`• Total Cost: ${(parseFloat(e.amount)+(e.estimatedFee||(0,s.calculateTxFee)())).toFixed(6)} TRX`),(0,a.text)(`• Network: ${e.networkStatus?.networkName||"Unknown"}`),(0,a.text)(`• Risk Level: ${this.getRiskEmoji(e.riskLevel?.level)} ${e.riskLevel?.level||"Unknown"}`)),t}buildNetworkStatus(e){return[(0,a.text)("**🌐 Network Status:**"),(0,a.text)(`• Congestion: ${{low:"🟢",medium:"🟡",high:"🔴"}[e.congestion]} ${e.congestion}`),(0,a.text)(`• Block Height: ${e.currentBlock.toLocaleString()}`),(0,a.text)(`• Avg Block Time: ${e.averageBlockTime}s`),(0,a.divider)()]}buildRiskAssessment(e){const t=[(0,a.text)(`**⚠️ Risk Assessment: ${this.getRiskEmoji(e.level)} ${e.level.toUpperCase()}**`),(0,a.text)(`Risk Score: ${e.score}/100`)];return e.warnings.length>0&&(t.push((0,a.text)("**Warnings:**")),e.warnings.forEach(e=>{t.push((0,a.text)(`• ${e}`))})),t.push((0,a.divider)()),t}buildFeeEstimation(e){return[(0,a.text)("**⛽ Fee Estimation:**"),(0,a.text)(`• Base Fee: ${e} TRX`),(0,a.text)("• Energy: Included"),(0,a.text)("• Bandwidth: Included"),(0,a.divider)()]}buildContractDetails(e){return[(0,a.text)("**📄 Smart Contract Interaction:**"),(0,a.text)(`• Type: ${e.contractType||"Unknown"}`),(0,a.text)(`• Method: ${e.method||"Unknown"}`),(0,a.divider)()]}buildSimulationResults(e){const t=[(0,a.text)("**🧪 Simulation Results:**"),(0,a.text)("• Status: "+(e.success?"✅ Success":"❌ Failed"))];return e.success?(void 0!==e.energyUsed&&t.push((0,a.text)(`• Energy Used: ${e.energyUsed.toLocaleString()}`)),void 0!==e.bandwidthUsed&&t.push((0,a.text)(`• Bandwidth Used: ${e.bandwidthUsed.toLocaleString()}`))):e.error&&t.push((0,a.text)(`• Error: ${e.error}`)),t.push((0,a.divider)()),t}getRiskEmoji(e){switch(e){case"low":return"🟢";case"medium":return"🟡";case"high":return"🔴";default:return"⚪"}}async analyzeTransactionRisk(e,t,n){const a=[];let r=0;(0,s.validateTronAddress)(e)||(a.push("Invalid recipient address format"),r+=50),await this.isNewAddress(e)&&(a.push("First transaction to this address"),r+=20);const o=await this.tronService.getBalance(),i=parseFloat(t)/parseFloat((0,s.formatTrx)(o))*100;let c;return i>50&&(a.push(`Sending ${i.toFixed(0)}% of your balance`),r+=30),await this.isContractAddress(e)&&(a.push("Recipient is a smart contract"),r+=15),c=r>=60?"high":r>=30?"medium":"low",{level:c,warnings:a,score:r}}async getNetworkStatus(e){try{return{congestion:"low",averageBlockTime:3,currentBlock:12345678,networkName:"mainnet"===e?"TRON Mainnet":"TRON Testnet (Shasta)"}}catch(t){return{congestion:"medium",averageBlockTime:3,currentBlock:0,networkName:e}}}async simulateTransaction(e,t,n){try{const n=(0,s.validateTronAddress)(e),a=await this.checkSufficientBalance(t);return n?a?{success:!0,energyUsed:5e3,bandwidthUsed:200}:{success:!1,error:"Insufficient balance"}:{success:!1,error:"Invalid recipient address"}}catch(e){return{success:!1,error:e.message||"Simulation failed"}}}async isNewAddress(e){return!1}async isContractAddress(e){return e.startsWith("TR")||e.startsWith("TE")}async checkSufficientBalance(e){const t=await this.tronService.getBalance(),n=parseFloat(e)+(0,s.calculateTxFee)();return parseFloat((0,s.formatTrx)(t))>=n}async getContractDetails(e,t){return await this.isContractAddress(e)?{isContract:!0,contractType:"TRC20",method:"transfer",params:t}:{isContract:!1}}}},940:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tronDatabase=t.TronDatabaseService=void 0;class n{static getInstance(){return n.instance||(n.instance=new n),n.instance}constructor(){this.isInitialized=!1}async initialize(){if(!this.isInitialized)try{await this.testConnection(),this.isInitialized=!0}catch(e){console.warn("Database not available, using snap state storage only:",e),this.isInitialized=!1}}async testConnection(){if(!process.env.DATABASE_URL)throw new Error("DATABASE_URL not available")}async storeUser(e,t){const n={id:Date.now(),address:e,network:t,createdAt:(new Date).toISOString()};try{return this.isInitialized,await this.storeInSnapState("user",n),n}catch(e){throw console.error("Failed to store user:",e),e}}async getUser(e){try{return this.isInitialized,await this.getFromSnapState("user")}catch(e){return console.error("Failed to get user:",e),null}}async storeDAppSession(e,t,n,a,s){const r={id:Date.now(),userId:e,origin:t,name:n,icon:a,chainId:s,isActive:!0,connectedAt:(new Date).toISOString(),lastAccessAt:(new Date).toISOString()};try{const n=(await this.getDAppSessions(e)).map(e=>e.origin===t?{...e,isActive:!1}:e);return n.push(r),await this.storeInSnapState("dappSessions",n),r}catch(e){throw console.error("Failed to store dApp session:",e),e}}async getDAppSessions(e){try{return(await this.getFromSnapState("dappSessions")||[]).filter(t=>t.userId===e)}catch(e){return console.error("Failed to get dApp sessions:",e),[]}}async getActiveDAppSessions(e){return(await this.getDAppSessions(e)).filter(e=>e.isActive)}async deactivateDAppSession(e,t){try{const n=(await this.getDAppSessions(e)).map(e=>e.origin===t?{...e,isActive:!1}:e);await this.storeInSnapState("dappSessions",n)}catch(e){console.error("Failed to deactivate dApp session:",e)}}async deactivateAllDAppSessions(e){try{const t=(await this.getDAppSessions(e)).map(e=>({...e,isActive:!1}));await this.storeInSnapState("dappSessions",t)}catch(e){console.error("Failed to deactivate all dApp sessions:",e)}}async storeTransaction(e,t,n,a,s,r,o,i,c){const d={id:Date.now(),userId:e,sessionId:t,txId:n,type:a,amount:s,toAddress:r,fromAddress:o,status:"pending",network:i,metadata:c,createdAt:(new Date).toISOString()};try{const t=await this.getTransactions(e);return t.unshift(d),t.length>100&&t.splice(100),await this.storeInSnapState("transactions",t),d}catch(e){throw console.error("Failed to store transaction:",e),e}}async getTransactions(e,t=50){try{return(await this.getFromSnapState("transactions")||[]).filter(t=>t.userId===e).slice(0,t)}catch(e){return console.error("Failed to get transactions:",e),[]}}async updateTransactionStatus(e,t){try{const n=(await this.getFromSnapState("transactions")||[]).map(n=>n.txId===e?{...n,status:t,confirmedAt:"confirmed"===t?(new Date).toISOString():n.confirmedAt}:n);await this.storeInSnapState("transactions",n)}catch(e){console.error("Failed to update transaction status:",e)}}async storeSignedMessage(e,t,n,a,s){const r={id:Date.now(),userId:e,sessionId:t,message:n,signature:a,messageHash:s,createdAt:(new Date).toISOString()};try{const t=await this.getSignedMessages(e);return t.unshift(r),t.length>50&&t.splice(50),await this.storeInSnapState("signedMessages",t),r}catch(e){throw console.error("Failed to store signed message:",e),e}}async getSignedMessages(e,t=25){try{return(await this.getFromSnapState("signedMessages")||[]).filter(t=>t.userId===e).slice(0,t)}catch(e){return console.error("Failed to get signed messages:",e),[]}}async storeInSnapState(e,t){const n=await snap.request({method:"snap_manageState",params:{operation:"get"}})||{};await snap.request({method:"snap_manageState",params:{operation:"update",newState:{...n,[e]:t}}})}async getFromSnapState(e){const t=await snap.request({method:"snap_manageState",params:{operation:"get"}});return t?.[e]}}t.TronDatabaseService=n,n.instance=null,t.tronDatabase=n.getInstance()}},t={};function n(a){var s=t[a];if(void 0!==s)return s.exports;var r=t[a]={exports:{}};return e[a](r,r.exports,n),r.exports}var a={};(()=>{var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.onRpcRequest=void 0;const t=n(360),s=n(218),r=n(328),o=n(116),i=n(848),c=n(484),d=new s.TronService,l=new i.TransactionPreviewService(d),u=new r.TronDAppConnector(d);e.onRpcRequest=async({origin:e,request:n})=>{try{switch(n.method){case"tron_connect":return await async function(){try{const e=await d.connect();if(await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)(c.i18n.t("connection.title")),(0,t.text)(c.i18n.t("connection.description")),(0,t.divider)(),(0,t.text)(c.i18n.t("connection.accountAddress")),(0,t.copyable)(e.address),(0,t.text)(c.i18n.t("connection.network")),(0,t.text)(e.network)])}}))return await snap.request({method:"snap_notify",params:{type:"inApp",message:c.i18n.t("connection.success")}}),e;throw new Error(c.i18n.t("connection.rejected"))}catch(e){throw new Error(`${c.i18n.t("connection.failed")}: ${e?.message||c.i18n.t("error.unknown")}`)}}();case"tron_getAccount":return await async function(){try{return await d.getAccount()}catch(e){throw new Error(`Failed to get account: ${e?.message||"Unknown error"}`)}}();case"tron_getBalance":return await async function(){try{const e=await d.getBalance();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("TRON Balance"),(0,t.text)(`**Balance:** ${(0,o.formatTrx)(e)} TRX`)])}}),{balance:(0,o.formatTrx)(e),unit:"TRX"}}catch(e){throw new Error(`Failed to get balance: ${e?.message||"Unknown error"}`)}}();case"tron_sendTransaction":return await async function(e){try{const{to:n,amount:a,memo:s}=e;if(!(0,o.validateTronAddress)(n))throw new Error(c.i18n.t("transaction.invalidAddress"));if(!a||parseFloat(a)<=0)throw new Error(c.i18n.t("transaction.invalidAmount"));const r=await d.getAccount(),i=await d.getBalance();if(parseFloat(a)>parseFloat((0,o.formatTrx)(i)))throw new Error(c.i18n.t("transaction.insufficientBalance"));const u=await l.getNetworkStatus(r.network),w=await l.analyzeTransactionRisk(n,a,r.address),p=await l.simulateTransaction(n,a,r.address),g=await l.getContractDetails(n),m={from:r.address,to:n,amount:a,memo:s,estimatedFee:1,networkStatus:u,riskLevel:w,contractInteraction:g,simulationResult:p},h=await l.buildTransactionPreview(m);if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)(h)}}))throw new Error("Transaction cancelled by user");const v=await d.sendTransaction(n,a,s);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Transaction sent! Hash: ${v}`}}),{txHash:v,status:"pending"}}catch(e){throw new Error(`Transaction failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_signMessage":return await async function(e){try{const{message:n}=e;if(!n)throw new Error("Message is required");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Sign Message"),(0,t.text)("**Message to sign:**"),(0,t.text)(n),(0,t.divider)(),(0,t.text)("This will sign the message with your TRON private key.")])}}))throw new Error("Message signing cancelled by user");return{signature:await d.signMessage(n)}}catch(e){throw new Error(`Message signing failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getTransactionHistory":return await async function(){try{const e=await d.getTransactionHistory();if(0===e.length)await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Transaction History"),(0,t.text)("No transactions found.")])}});else{const n=e.slice(0,5).map(e=>[(0,t.text)(`**${e.type}** - ${(0,o.formatTrx)(e.amount)} TRX`),(0,t.text)(`To: ${e.to}`),(0,t.text)(`${new Date(e.timestamp).toLocaleDateString()}`),(0,t.divider)()]).flat();await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Recent Transactions"),...n])}})}return e}catch(e){throw new Error(`Failed to get transaction history: ${e?.message||"Unknown error"}`)}}();case"tron_switchNetwork":return await async function(e){try{const{network:n}=e;if(!["mainnet","testnet"].includes(n))throw new Error('Invalid network. Use "mainnet" or "testnet"');if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Switch TRON Network"),(0,t.text)(`Switch to TRON ${n}?`),(0,t.divider)(),(0,t.text)("This will change your current network connection.")])}}))throw new Error("Network switch cancelled by user");return await d.switchNetwork(n),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Switched to TRON ${n}`}}),{network:n}}catch(e){throw new Error(`Failed to switch network: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_connect":return await async function(e){try{const{origin:t,name:n,icon:a}=e||{};if(!t||!n)throw new Error("dApp origin and name are required");const s=await u.connectDApp({origin:t,name:n,icon:a});return{connected:!0,session:{accounts:s.accounts,chainId:s.chainId,origin:s.origin,name:s.name}}}catch(e){throw new Error(`Failed to connect dApp: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_dapp_sessions":return await async function(){try{const e=u.getActiveSessions();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Active dApp Connections"),...0===e.length?[(0,t.text)("No active dApp connections.")]:e.map(e=>[(0,t.text)(`**${e.name}**`),(0,t.text)(`Origin: ${e.origin}`),(0,t.text)(`Connected: ${new Date(e.connectedAt).toLocaleString()}`),(0,t.divider)()]).flat()])}}),{sessions:e}}catch(e){throw new Error(`Failed to get sessions: ${e?.message||"Unknown error"}`)}}();case"tron_dapp_disconnect":return await async function(e){try{const{origin:t,all:n}=e||{};if(n)await u.disconnectAll();else{if(!t)throw new Error("Must specify origin or all=true");await u.disconnectDApp(t)}return{disconnected:!0}}catch(e){throw new Error(`Failed to disconnect: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_stake":return await async function(e){try{const{amount:n,resource:a="ENERGY"}=e;if(!n||parseFloat(n)<=0)throw new Error("Invalid staking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Stake TRX"),(0,t.text)(`You are about to stake **${(0,o.formatTrx)(n)} TRX** for **${a}**.`),(0,t.divider)(),(0,t.text)("**Staking Details:**"),(0,t.text)(`• Resource: ${a}`),(0,t.text)("• Lock Period: 3 days"),(0,t.text)("• You can unstake anytime, but need to wait 14 days to withdraw"),(0,t.divider)(),(0,t.text)("**Benefits:**"),(0,t.text)("• Earn voting rights (1 TRX = 1 vote)"),(0,t.text)(`• Get free ${a.toLowerCase()} for transactions`),(0,t.text)("• Support the TRON network")])}}))throw new Error("Staking cancelled by user");const s=await d.stakeTRX(n,a);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully staked ${(0,o.formatTrx)(n)} TRX for ${a}`}}),{txHash:s,amount:n,resource:a}}catch(e){throw new Error(`Staking failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_unstake":return await async function(e){try{const{amount:n,resource:a="ENERGY"}=e;if(!n||parseFloat(n)<=0)throw new Error("Invalid unstaking amount");if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Unstake TRX"),(0,t.text)(`You are about to unstake **${(0,o.formatTrx)(n)} TRX** from **${a}**.`),(0,t.divider)(),(0,t.text)("**Important:**"),(0,t.text)("• Unstaked TRX will be locked for 14 days"),(0,t.text)("• You will lose voting rights for this amount"),(0,t.text)(`• Free ${a.toLowerCase()} will be reduced`),(0,t.divider)(),(0,t.text)("Are you sure you want to continue?")])}}))throw new Error("Unstaking cancelled by user");const s=await d.unstakeTRX(n,a);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully unstaked ${(0,o.formatTrx)(n)} TRX. Available for withdrawal in 14 days.`}}),{txHash:s,amount:n,resource:a}}catch(e){throw new Error(`Unstaking failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_vote":return await async function(e){try{const{votes:n}=e;if(!n||!Array.isArray(n)||0===n.length)throw new Error("Invalid votes parameter");const a=n.reduce((e,t)=>e+(t.count||0),0),s=await d.getStakingInfo(),r=Math.floor(s.frozen);if(a>r)throw new Error(`Insufficient voting power. You have ${r} votes available.`);const o=n.map(e=>[(0,t.text)(`• ${e.name||e.address.substring(0,10)+"..."}: **${e.count} votes**`)]).flat();if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Vote for Super Representatives"),(0,t.text)(`Total Votes: **${a}** / ${r} available`),(0,t.divider)(),(0,t.text)("**Your Votes:**"),...o,(0,t.divider)(),(0,t.text)("**Note:**"),(0,t.text)("• Votes are updated every 6 hours"),(0,t.text)("• You can change votes anytime"),(0,t.text)("• Voting helps secure the network")])}}))throw new Error("Voting cancelled by user");const i=await d.voteForSR(n);return await snap.request({method:"snap_notify",params:{type:"inApp",message:`Successfully voted for ${n.length} Super Representative(s)`}}),{txHash:i,votes:n.length,totalVotes:a}}catch(e){throw new Error(`Voting failed: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getStakingInfo":return await async function(){try{const e=await d.getStakingInfo(),n=e.votes.length>0?e.votes.map(e=>(0,t.text)(`• ${e.name}: ${e.votes} votes`)):[(0,t.text)("No active votes")];return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Staking Information"),(0,t.divider)(),(0,t.text)("**Staked Balance:**"),(0,t.text)(`• Total: ${(0,o.formatTrx)(e.frozen.toString())} TRX`),(0,t.text)(`• For Energy: ${(0,o.formatTrx)(e.frozenEnergy.toString())} TRX`),(0,t.text)(`• For Bandwidth: ${(0,o.formatTrx)(e.frozenBandwidth.toString())} TRX`),(0,t.divider)(),(0,t.text)("**Voting Power:**"),(0,t.text)(`• Available: ${Math.floor(e.frozen)} votes`),(0,t.divider)(),(0,t.text)("**Active Votes:**"),...n,(0,t.divider)(),(0,t.text)(`**Rewards:** ${(0,o.formatTrx)(e.rewards.toString())} TRX`)])}}),e}catch(e){throw new Error(`Failed to get staking info: ${e?.message||"Unknown error"}`)}}();case"tron_getSuperRepresentatives":return await async function(){try{const e=await d.getSuperRepresentatives(),n=e.slice(0,5).map(e=>[(0,t.text)(`**#${e.ranking} ${e.name}**`),(0,t.text)(`Votes: ${(e.totalVotes/1e6).toFixed(2)}M`),(0,t.text)(`Productivity: ${e.productivity.toFixed(1)}%`),(0,t.divider)()]).flat();return await snap.request({method:"snap_dialog",params:{type:"alert",content:(0,t.panel)([(0,t.heading)("Top Super Representatives"),(0,t.text)("Vote for SRs to earn rewards and support the network"),(0,t.divider)(),...n,(0,t.text)("... and more")])}}),e}catch(e){throw new Error(`Failed to get Super Representatives: ${e?.message||"Unknown error"}`)}}();case"tron_withdrawExpiredUnfrozen":return await async function(){try{if(!await snap.request({method:"snap_dialog",params:{type:"confirmation",content:(0,t.panel)([(0,t.heading)("Withdraw Unfrozen Balance"),(0,t.text)("Withdraw any TRX that has completed the 14-day unstaking period."),(0,t.divider)(),(0,t.text)("This will transfer all available unfrozen TRX back to your account.")])}}))throw new Error("Withdrawal cancelled by user");const e=await d.withdrawExpiredUnfrozen();return await snap.request({method:"snap_notify",params:{type:"inApp",message:"Successfully withdrew unfrozen balance"}}),{txHash:e}}catch(e){throw new Error(`Withdrawal failed: ${e?.message||"Unknown error"}`)}}();case"tron_setLanguage":return await async function(e){try{const{language:t}=e,n=c.i18n.getAvailableLanguages().map(e=>e.code);if(!n.includes(t))throw new Error(`Invalid language. Supported: ${n.join(", ")}`);return await c.i18n.setLanguage(t),await snap.request({method:"snap_notify",params:{type:"inApp",message:c.i18n.t("common.success")}}),{language:t,success:!0}}catch(e){throw new Error(`Failed to set language: ${e?.message||"Unknown error"}`)}}(n.params);case"tron_getLanguage":return await async function(){try{return{current:c.i18n.getLanguage(),available:c.i18n.getAvailableLanguages()}}catch(e){throw new Error(`Failed to get language: ${e?.message||"Unknown error"}`)}}();default:throw new Error(`Method ${n.method} not supported`)}}catch(e){throw console.error("RPC request error:",e),await snap.request({method:"snap_notify",params:{type:"inApp",message:`Error: ${e?.message||"Unknown error"}`}}),e}}})();var s=exports;for(var r in a)s[r]=a[r];a.__esModule&&Object.defineProperty(s,"__esModule",{value:!0})})();